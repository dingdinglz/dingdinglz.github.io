[{"content":"本周工作状态 关于 或许我会写些开发方面的小技巧，也许我正计划着做些关于golang和c的教程for初学者们。\n也许我只是想写点生活中平平淡淡的东西。\n联系我 mail: dinglz@mail.dlut.edu.cn\n友链 荷雨头上插着薄荷🍀 ℡傲雪\u0026amp;星火ぴ Java之父のblog（牢万） 印象平凡 ","date":"2024-10-15T08:00:00Z","image":"https://dingdinglz.github.io/p/hello-world/cover_hu6307248181568134095.jpg","permalink":"https://dingdinglz.github.io/p/hello-world/","title":"Hello World"},{"content":"今天我们要看的项目是：https://github.com/HKUDS/DeepCode ，\n概述 DeepCode 是一个基于多智能体系统的开源框架，旨在将研究论文、自然语言描述等输入自动转换为生产级代码。该项目通过自动化算法实现、前端开发和后端构建，显著提升了研发效率。其核心目标是解决研究人员在实现复杂算法时面临的挑战，减少开发延迟，并避免重复性编码工作。\nDeepCode 支持多种输入形式，包括学术论文、文本提示、URL 和文档文件（如 PDF、DOC、PPTX、TXT、HTML），并能生成高质量、可扩展且功能丰富的代码。该系统采用多智能体协作架构，能够处理复杂的开发任务，从概念到可部署的应用程序。\nflowchart LR A[\u0026#34;📄 研究论文\u0026lt;br/\u0026gt;💬 文本提示\u0026lt;br/\u0026gt;🌐 URLs \u0026amp; 文档\u0026lt;br/\u0026gt;📎 文件: PDF, DOC, PPTX, TXT, HTML\u0026#34;] --\u0026gt; B[\u0026#34;🧠 DeepCode\u0026lt;br/\u0026gt;多智能体引擎\u0026#34;] B --\u0026gt; C[\u0026#34;🚀 算法实现 \u0026lt;br/\u0026gt;🎨 前端开发 \u0026lt;br/\u0026gt;⚙️ 后端开发\u0026#34;] style A fill:#ff6b6b,stroke:#c0392b,stroke-width:2px,color:#000 style B fill:#00d4ff,stroke:#0984e3,stroke-width:3px,color:#000 style C fill:#00b894,stroke:#00a085,stroke-width:2px,color:#000 ","date":"2025-09-28T02:00:00Z","permalink":"https://dingdinglz.github.io/p/dinglz%E5%B8%A6%E4%BD%A0%E8%AF%BBdeepcode/","title":"dinglz带你读deepcode"},{"content":"日记 相比于直接一股脑地把我的看法吧啦吧啦说出来，我更想先聊聊从暑假开始到现在我的经历，所以前面应该算是日记时间，不想看的朋友可以直接跳过\nLet\u0026rsquo;s go!\n先说说大概的过程吧\n日本行 西安实习 AdventureX Vivo夏令营 在家蹲着 日本行 结束了该死的期末周，被折磨了一个学期筋疲力尽，心中怀着对后面几个活动的期待，去日本玩玩。当时去之前还琢磨着干各种事情，比如说灵码杯的发起与筹办，我承认灵码杯确实是受到了AdventureX的启发，但确实是我遵循内心做出的一个正确的选择（为什么说正确呢我们后面再聊）在考完和等待去日本的时间里，我就一直在1.完成软件杯的作品 2.办灵码杯，从考完试，我就开始联系灵码的工作人员也就是雅纯姐姐，她给了我很大的鼓励和支持，让我有信心能把灵码杯办起来，很难想象我在五天内完成了从策划到拉到赞助到说服学校老师的全部流程，在日本期间完成了灵码杯的宣发。\n灵码杯的想法呢最初也得到了政阳哥哥，文聪哥哥，源东哥哥，浩然哥哥的认可和支持，所以我们组成赛事组开始办这个赛事，不管是从经验，工作，资源上他们都在很大程度上帮助了我，总之这件事算是办了，然后就是安心在日本玩的过程，想起来来日本之前的几天，宇轩还跟我说别想那么多，不如想想怎么在日本好好玩玩（，事实证明他说的对，不过得益于我的好室友是日本通，所以我们在日本仍然玩的非常开心（在我本人完全没做准备的情况下hhh）\n整个日本游让我对日本有了很大的改观\n就是这种感觉你们懂吧hhh\n最让我喜欢的可能是日本随处可及的那种咖啡厅的氛围，就是什么都不做，朋友们聊聊天，或者单纯坐着\n这是宇治\n好喜欢这种古老和现代结合的感觉，带来了宁静\n日本之行就聊这么多吧，然后匆匆赶赴西安\n西安实习 我对西安的第一印象就是热，这个古城的氛围我倒是没怎么感受到（可能因为太热了没出门，bushi。肉夹馍超级好吃，打工的早晨吃的基本上都是肉夹馍，有时候晚上也吃\n说起来来西安之前，我对这次实习还是蛮期待的，当时的面试官和我聊的理念让我还是蛮兴奋的，确实很符合我当时的一些想法（当时）总之是做一家vibe coding插件的公司，然后员工拿自己家的插件做一些外包的活。\n然后，\n事实证明：AI也需要开发者有相关的开发经验和功底，不是随便来几个小白就能立马上手的\n这次给我最大的经验就是，AI还远不能替代程序员的活，还有很长的路要走，由于被几个小白教我干活，不算太愉快，这个经历我们弃之不谈，算是给我涨涨教训，收获几乎没有\n西安实习中间去了一次济南，看法老的演唱会，顺便跟我几个高中好朋友会面，还是蛮感慨的，看到大家都有自己的事情在做，每个人也变了很多，圈子一直在变，人也在一直向前，我们也不要为了分开而悲伤嘛，总之小聚，然后回去继续实习\n千等万等终于等来了杭州行，这个暑假收获最大的，AdventureX\nAdventureX 先说说看我对于AdventureX的看法，我知道网上对它的骂声很多，也有一堆不好的瓜，但是对于活动本身我觉得没有问题，很少有能把这八百个人聚在这里的机会了，所以我拒绝对它的批评，为此我还和群友吵了一架\n我觉得这能代表我的态度了，所以对这件事不谈，聊聊我这五天前后中的经历\n首先第一天是好友聚餐环节：\n下午线上聊了本科大工现在南大的容贤学长，互相聊了经历，主要听了听他办南客松（全南京市的黑客松）的经验，学到了很多，又指导了我学习，创业，开发上的很多疑惑。\n很高兴和很多朋友有了线下见面一起喝咖啡聊天的经历，和来自西交利物浦，大二辍学去硅谷创业的Klein，钉钉呆过，打完advx就入职字节的sky，川大美术的转转聊了很久，第一天就感受到了共鸣真好，有一种找到“同类”的感觉hhh。学到了很多，比如怎么去看问题，怎么去抓用户需求，什么是一个好的产品。我觉得这些没有标准答案，但大家的理解对我启发都很大。\n然后晚上吃火锅的时候又来了一堆朋友，晚上去酒吧喝酒，又面基了之前就认识，大一创业的区同学，还有很多很多优秀的朋友。\n总之第一天就感受到了那种氛围，开始格外期待起advx的第一天。\n来啦！\n上午提前和我的队友打个照面，一个很了不起的连续创业者，然后逛展，很遗憾我advx的逛展次数就两次，这一次和展会那一天，上午把所有展会都逛了，顺了整整四袋子物料，为此我在出发去下一个地点之前还寄了三个袋子回合肥，展会上见到了很多朋友，中午出去吃了个饭。\n下午我们现场寻找我们的另一个队友，说来也好笑，我们本来有一个超强的设计师姐姐，但是因为台风被困在香港了，所以只能现场寻觅队友。好在文慧给我们推荐了一个杭电的小姑娘，美术同学，可惜的是她没有figma经验，更多是游戏方面的美术经验。不过没有关系，作为一个优秀的vibe coder，肯定得发挥前端上ai的主观能动性（bushi，当然美术同学也给我们提供了很多ui上的指导和图片素材，我是不会承认我提交作品前一个小时还在被逮着改ui的（bushi\n下一天让我印象最深的是上午的共绩算力关于共享算力的workshop，AI平权的理念也在我这埋了一颗很深很深的种子，晚上见到了容贤学长，可惜因为大家都忙着coding，没时间交流哈哈哈。\n再往后一天我记得也是全天的coding，但是见到了很多有意思的项目，比如结印编程哈哈哈，给我帅麻了\n还有那个很有名的马桶\n然后和来自OSChengDu的poly面基了，非常谦虚也很有实力的大佬，偶遇了Soulter，后来在群友介绍下才发现是AstroBot的作者哈哈哈，早知道拷打一下了。\n晚上和一个投资人深度chat了很久，给我的启发很大，变得越来越想创业（bushi\n敲代码的最后一天，还是疯狂敲代码，准备物料\n这一天受到了几家初创和一些伙伴的合伙邀请：\n比如说一个UGC平台，一个社交辅助（我一开始还误认为是类似于date app，后来聊过才发现是ai帮人聊天这种），收到了老哥很大的思路开阔上的帮助，okok稳的\n又聊了几个投资人，其中一个口出狂言（不是，说现在他愿意投我，但是等我大学毕业了就不一定了，创业一定要趁早\n这一天看了真格的分享，我觉得很有意思，和大家分享分享：\n最后一天，路演，讲了一个上午加一个中午，超累，得到了很多很多的认可，也因此加了很多很多大佬，但这些不谈，我更想和大家聊聊我下午逛的时候看到的很多有趣的项目。\n你和这只狗狗很像 项目就是帮你找到和你长的最像的那只狗，很有意思，目的是为了让你收留这只长的和你最像的流浪狗，跟他们开发聊了下把这套系统迁移到猫身上的可能性，得到了猫毛太多，不好做面部识别的结论，有点失望\n给国足设计的足球 总之就是不管你怎么踢，这只足球都能利用CV和内部的滚轮把自己送进球门，为国足正名！\n和马斯克合了影 很难解释，看图吧\n晚上闭幕式，很高兴甚至拿了个kimi for vibe赛道的奖（本来没想着拿奖的捏\n晚上出去和新认识的几个朋友聊天，他们有一个创业idea，很高兴说动了我，大家决定一起做，我作为CTO“加盟”了他们\n第二天游西湖，好耶！\n结束了这个令我印象极其深刻的活动，飞深圳！\n在深圳之前还有认识了几个想搞黑客松的朋友，这次advx算是给大家打了个样，全国各种黑客松组织开始兴起，企业和投行开始变得愿意为黑客松买单，这也是我在文章一开始说灵码杯是个正确的决定的原因。但是由于这次advx发生了一些事情（不想说了）所以大家想办真正属于我们自己的黑客松，我遇到了D哥，他有理想，也有资源去办一场新的全国性的大型黑客松，他也在寻找志同道合的人一起办这个事情，所以我加入了他们，我们把这叫做“创客松”，我们也在前期准备阶段，筹办下一次超大型的黑客松，真正打动我的一些理念，像让来自贫穷地区的孩子也能接触到这些资源，这就不得不说我自己，我感觉我从小到大一更像是在沉淀阶段，一直一直学习知识，直到这个暑假才有走向更大舞台的机会，也感谢我自己的这种热情让我能有现在的能力，但是如果我能在我小时候接触到像探月学校这样的资源都话，成就肯定远不止我现在，总之很感概。另一个就是办不去讨好投资人的黑客松，只是为了见证创造，这对我们而言就够了，我们就是想看那些了不起的想法，想见证那些或许大家觉得没有任何意义的创造，这太酷了！推动推动推动，希望能早早地和大家见面。\n回归主线，飞深圳！\nVivo夏令营 这三天印象最深的事情，是学习了一项新技能：搓麻将（bushi，神奇的vivo给我们安排的房间里有台麻将机，所以我们每天晚上回去都在搓麻将hhh，以及惯蛋，想不到在安徽之外还能见识到这个玩法\n没错我们三个神人在这玩24点玩了一个小时，由于传统玩法被我们秒了，所以大家开发了位运算，左移右移这种玩法，鉴定为学计算机学的（bushi\n当然也是有很多收获，比如学习了微调技巧和端侧模型部署，（又咨询了wc学长很多，wc哥哥太强辣）和vivo投资老总说上了话，学习到了演讲技巧（bushi。参观了vivo工厂，超棒。\n结束以后没直接飞回家，而是跑到广州去找政阳哥哥聊天，我俩在夏令营一天晚上就聊了很久很久，我还是要再表达一遍对政阳哥哥的感谢，作为我大一时期的引路人，切切实实帮助了我很多很多，也纠正了我不少想法，引领我走上了正确的道路。这次来到广州，参观了企业微信和微信，又聊了聊创新，创业，黑客松。我趁机拿我的一些业务咨询了政阳哥哥，也得到了不小的启发哈哈哈，这次又从政阳哥哥身上学了很多，飞回家！\n在家蹲着 在家蹲着期间干了哪些事呢：\n完成了灵码杯第二次分享，一切有条不紊！参赛队伍达到115支，是我设想情况的两倍，超级期待看到大家的作品！\n跟D哥，行知哥聊黑客松的筹备和安排，和mark老师请教黑客松的一些事项，我们在憋一个大活！大家期待啊哈哈哈\n完成了我们自家初创的前期准备，跟一个超好的学长聊了很久，基本解决了我关于搜广推的全部疑惑，也是政阳哥哥推荐的，感恩！\n参加了一家初创项目的前期研究环节，可以透露下也是在做agent，因此得到了超棒的思路和资源\n感悟 For AI创业 AI创业超级欢迎年轻人，我见到了一堆高中生CEO，现在是AI时代的开始，现在抓住机会是最好的时间点\n创业初期不要去想核心竞争力，套壳（Agent）完全没问题！想想Manus吧，早期完全不用担心被抄袭等等问题，自信Forever\n好的产品一定是Dog Feeding的，即自己会用自己做出来的东西，这个产品才是有用的，不要去抓伪需求，找真需要！\n创业最好的机会一个是在十年前，一个是现在\n不要觉得创业很帅很光鲜亮丽，我身边的CEO朋友们从来不说自己是CEO，创业是过独木桥，成功的是极少数，不要在乎头衔，也不要总拿头衔说事\n总之\u0026mdash;-仰望创业者\nFor 黑客松 主要聊聊我为什么想办黑客松：\n我觉得我目前呆的地方（DUT）创新创业氛围不够，我想看到更多创新在这里发生，这是我发起灵码杯最真实的想法\n我觉得不公平，需要让大家接触到一样的资源，就好像上文我谈到的，因为呆的地方不能得到更好的发展，这太不酷了，我们可以为大家带来什么？就业、读研、创业我们不该为大家指定任何一条路！所以我们能做的就是把资源带给大家，至少留给大家一个选择的机会，这就足够了，不要因为接触不到错过这个选择。\n这是个很好的平台，我认识了很多挚友，也见证了很多伟大的项目\nFor Vibe Coding 有幸体验过世面上近乎全部vibe coding产品的我聊一聊我的看法，首先先给个排名（我心目中，不代表真实情况），后面有机会再给大家更新详细的测评：cline + claude4 \u0026gt; claude code + claude4 \u0026gt; argument code \u0026gt; cline +gemini \u0026gt; claude code + k2 \u0026gt; kiro \u0026gt; cursor \u0026gt; windsurf \u0026gt; trae \u0026gt; void\nvibe coding不意味着不再需要需要编程，意味着需要开发者有更高的架构意识，指挥能力\n以后大家将离不开vibe coding，所以所有人都要转变成全栈工程师，否则就会被淘汰，这点在初创公司中体现的尤为明显\n目前来看vibe coding还是离不开designer，有设计稿再去生成前端界面会更加美观和高效，vibe coding的ui太过同质化且没有想象力\n一定要同时保证自己的开发能力，多去了解新的技术栈（如果你自己都不了解怎么让ai去用？ai只会用它最熟的技术栈（在不指定的情况下））所以我现在虽然因为一些活时间很紧，还是vibe coding为主，但是自己做的项目都是要求自己纯手写，古法编程万岁🎉！\n总结 复盘能聊的差不多也就这些了，总算是有时间停下来好好思考思考，这段时间感觉一直在被事情推着走而不是我推着事情走，希望大家有时间的话还是要慢下来好好想想自己的方向\n","date":"2025-08-11T02:00:00Z","permalink":"https://dingdinglz.github.io/p/%E6%9A%91%E5%81%87%E6%B8%B8%E8%AE%B0%E5%8F%8A%E6%84%9F%E6%82%9F/","title":"暑假游记及感悟"},{"content":"大一总结 大一最后一个漫长的期末周终于结束了，一个充实的大一，本篇主要记录下暑期规划\n比赛方面 Vivo AIGC进入复赛，完成复赛内容 Oppo智能交互进入复赛，完成复赛内容 中国大学生软件杯，初赛 举办比赛 预备暑假期间开展vibe coding竞赛 活动方面 参加7月份AdventureX，杭州见！ 实习方面 智识神工暑期实习，西安见！ 项目方面 建设TIC新门户网站 继续推动社区志愿网站 继续推动UI-Generator、Backend-Generator 完成与老师合作微调项目 ","date":"2025-06-19T02:00:00Z","permalink":"https://dingdinglz.github.io/p/%E6%9A%91%E5%81%87%E8%AE%A1%E5%88%92/","title":"暑假计划"},{"content":"背景 作为一个全栈开发，但通常来说以后端居多，平常写前端也基本上就是自己把接口写完了再去对接，因此接触到mock比较少（应该来说对前端仅限于能跑就行的程度），由于近期比赛与其他同学合作，处于引导后端同学自主开发的想法，我主动承接了前端的工作，并表示不会参与后端的任何工作，但是！由于某同学迟迟部署不成功，拿不到上线的接口的我只能开始学习mock（）\n什么是mock Mock（模拟）是软件开发中一种重要的技术，特别是在前端开发中，它允许开发者在没有真实后端服务的情况下进行开发和测试。\nMock 是指创建模拟对象或数据来替代真实依赖项的技术。在前端开发中，Mock 主要用于：\n模拟后端 API 响应 模拟浏览器 API 或环境 模拟第三方服务 在测试中隔离被测代码 Mock Service Worker（MSW）是一个用于浏览器和 Node.js 的 API 模拟库。使用 MSW，您可以拦截发出的请求，观察它们，并使用模拟响应来回答它们。\n下文中就介绍如何利用msw.js来进行mock操作，链接：https://mswjs.io/\n安装 1 npm i msw --save-dev msw.js依赖一个worker工作，在正式使用之前，我们需要把工作脚本导入public目录\n1 npx msw init \u0026lt;PUBLIC_DIR\u0026gt; --save 模拟接口 首先，我们需要用一个数组来定义我们要模拟的接口列表，例如：\n1 2 3 4 5 6 7 8 9 10 import { http, HttpResponse } from \u0026#39;msw\u0026#39; export const handlers = [ http.get(\u0026#39;/user\u0026#39;, () =\u0026gt; { return HttpResponse.json({ firstName: \u0026#39;John\u0026#39;, lastName: \u0026#39;Maverick\u0026#39;, }) }), ] 该例子就是模拟了\u0026rsquo;/user\u0026rsquo;这个get接口，可以看到，模拟返回值是一个json\n初始化worker并启动 在main.js中使用如下代码：\n1 2 3 4 5 import { setupWorker } from \u0026#39;msw/browser\u0026#39; import { handlers } from \u0026#39;./handlers\u0026#39; export const worker = setupWorker(...handlers) worker.start() 即可启动mock，在控制台看到：[MSW] Mocking enabled.即为启动成功\n在实际使用中，我们可以通过import.meta.MODE区分生产环境和开发环境来决定是否启动mock（vite下）\n会遇到的问题 worker必须要在https和受信任的证书下才能工作，所以我们需要借助mkcert：https://github.com/FiloSottile/mkcert生成证书\nmkcert安装 以brew为例：\n1 brew install mkcert 如果你想在firefox上开发，你还需要安装nss\n1 brew install nss 安装mkcert为受信任的证书机构 1 mkcert -install 安装后，生成的证书可以被浏览器信任，而不是显示为不安全的证书\n生成证书 1 mkcert -key-file key.pem -cert-file cert.pem localhost 生成了key.pem和cert.pem\nnode中启用https 以vite为例：vite.config.js：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import {defineConfig} from \u0026#39;vite\u0026#39; import vue from \u0026#39;@vitejs/plugin-vue\u0026#39; import fs from \u0026#34;fs\u0026#34;; // https://vite.dev/config/ export default defineConfig(({command, mode}) =\u0026gt; { if (mode === \u0026#39;development\u0026#39;) { // development 模式下启用https return { plugins: [vue()], server: { https: { key: fs.readFileSync(\u0026#39;./key.pem\u0026#39;), cert: fs.readFileSync(\u0026#39;./cert.pem\u0026#39;) }, } } } return { plugins: [vue()], } }) 后记 我们大前端终于独立了口牙\n","date":"2025-06-03T02:00:00Z","permalink":"https://dingdinglz.github.io/p/mock-msw.js/","title":"mock - msw.js"},{"content":"前言 一个网站后端的核心功能当然是一个http server，但除了server之外还有其他需要设计的部分，比如生成配置文件啊，第一次使用引导安装啊，重新初始化，迁移数据，导出数据等等，直接运行应用后就启动一个http server并不是最优秀的选择。\n因此，本篇blog将带领大家利用Cobra（Cobra 是一个用于创建强大的现代 CLI 应用程序的库。）和Pterm（PTerm 是一个现代的 Go 模块，可轻松美化控制台输出）来构建应用\n我们需要实现的效果如下（应用名是test）：\ntest version显示版本号 test server启动服务器 命令框架 cobra的使用方法请大家自行参阅文档～\n首先，我们构建基础命令\n1 2 3 4 5 rootCmd := \u0026amp;cobra.Command{ Use: \u0026#34;test\u0026#34;, Short: \u0026#34;一个测试应用\u0026#34;, Long: \u0026#34;一个测试应用，用来演示\u0026#34;, } Version命令\n1 2 3 4 5 6 7 8 versionCmd := \u0026amp;cobra.Command{ Use: \u0026#34;version\u0026#34;, Short: \u0026#34;版本号\u0026#34;, Long: `获取test的版本信息`, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;test v0.1 beta\u0026#34;) }, } Server命令\n1 2 3 4 5 6 7 8 serverCmd := \u0026amp;cobra.Command{ Use: \u0026#34;server\u0026#34;, Short: \u0026#34;启动服务器\u0026#34;, Long: \u0026#34;启动test的服务器服务\u0026#34;, Run: func(cmd *cobra.Command, args []string) { // 启动服务器... }, } 添加到基础命令\n1 2 rootCmd.AddCommand(versionCmd) rootCmd.AddCommand(serverCmd) 解析\n1 rootCmd.Execute() 当前完整代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/cobra\u0026#34; ) func main() { rootCmd := \u0026amp;cobra.Command{ Use: \u0026#34;test\u0026#34;, Short: \u0026#34;一个测试应用\u0026#34;, Long: \u0026#34;一个测试应用，用来演示\u0026#34;, } versionCmd := \u0026amp;cobra.Command{ Use: \u0026#34;version\u0026#34;, Short: \u0026#34;版本号\u0026#34;, Long: `获取test的版本信息`, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;test v0.1 beta\u0026#34;) }, } serverCmd := \u0026amp;cobra.Command{ Use: \u0026#34;server\u0026#34;, Short: \u0026#34;启动服务器\u0026#34;, Long: \u0026#34;启动test的服务器服务\u0026#34;, Run: func(cmd *cobra.Command, args []string) { // 启动服务器... }, } rootCmd.AddCommand(versionCmd) rootCmd.AddCommand(serverCmd) rootCmd.Execute() } 编译并运行./test\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 一个测试应用，用来演示 Usage: test [command] Available Commands: completion Generate the autocompletion script for the specified shell help Help about any command server 启动服务器 version 版本号 Flags: -h, --help help for test Use \u0026#34;test [command] --help\u0026#34; for more information about a command. 可以看到，基础的命令框架已经搭建完成，我们可以通过./test help，./test version来测试一下，那么，我们要添加额外的功能只需要添加到子命令中即可，./test server则是启动主服务的方式\n美化输出 后端的信息展示和日志等也是非常重要的，可以帮助我们进行溯源等等，因此我们引入pterm来美化输出，比如version命令我们可以先用大字美化。\n1 2 pterm.DefaultBigText.WithLetters(putils.LettersFromString(\u0026#34;test\u0026#34;)).Render() fmt.Println(\u0026#34;test v0.1 beta\u0026#34;) 又或者是将日志替换成pterm的logger\n1 2 3 4 logger := pterm.DefaultLogger.WithLevel(pterm.LogLevelTrace) logger.WithCaller().Debug(\u0026#34;我是Debug\u0026#34;) logger.Info(\u0026#34;你好呀\u0026#34;) logger.Debug(\u0026#34;我是Debug\u0026#34;) 更多妙用如进度条，选择器，表格等等命令行美化请查找pterm文档，本文仅提供部分思路\n后记 本文介绍了构建后端服务器的结构，将单一服务器启动变成支持多功能，大家在开发自己的应用之前就要考虑好架构的设计，功能的拓展，随着时间的堆积才不会让代码越来越臃肿。\n","date":"2025-05-13T02:00:00Z","permalink":"https://dingdinglz.github.io/p/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%AB%98%E6%95%88%E7%9A%84%E7%BD%91%E7%AB%99%E5%90%8E%E7%AB%AF%E5%BA%94%E7%94%A8/","title":"如何构建一个高效的网站后端应用"},{"content":"Intro 本文章主要介绍如何用golang的eino框架，加上mcp，实现一个绘制思维导图的小工具，项目目前已经开源在：https://github.com/dingdinglz/mind-maker ，实现的效果可以进入仓库查看readme， 本文主要聊聊设计思路，什么是mcp，如何调用mcp\nmcp 什么是mcp MCP 是一个开放协议，它标准化了应用程序如何向大型语言模型（LLMs）提供上下文。可以将MCP想象成AI应用的USB-C端口。正如USB-C提供了一种标准化的方式来连接你的设备到各种外围设备和配件，MCP提供了一种标准化的方式来连接AI模型到不同的数据源和工具。\n其实也就是为llm提供三方工具，让llm获得更多的能力，但这似乎听起来很像tool call，mcp与tool call相比，在于将工具整合起来，并且提供了标准的协议进行通信。在调用的底层，其实也就是将mcp的每个函数加载成tool的形式提供给llm。\n但是，mcp可以由提供服务的厂家开发，而并非使用llm的人自己，方便了快速集成工具。\n为什么mcp MCP 帮助你在大型语言模型（LLM）之上构建代理和复杂的工作流程。LLM 经常需要与数据和工具集成，MCP 提供：\n一个不断增长的工具集成列表，你的 LLM 可以直接接入 在不同的 LLM 提供商和供应商之间可以灵活切换 在您的基础设施内保护您的隐私数据 怎么mcp mcp的调用形式目前分为两种，一种是stdio，一种是sse，前者是通过类似于调用命令行的方法去传递数据和取得结果，后者是利用sse进行通信。\n大部分语言目前已经有了三方实现的mcp-client包，因此我们对于实现的技术细节可以不那么关心。\n我们在项目中用到的，调用mcp的golang包是mcp-go，它同样可以作为server的开发工具包\neino https://www.cloudwego.io/zh/docs/eino/\n看该blog之前把eino的用法看一遍\n什么是eino Eino 是基于 Golang 的 AI 应用开发框架 ， 类似于python的langchain\neino的优势 eino集成了相当多的大模型调用协议 eino提供了一种以图的形式，进行ai调用能力编排的功能 eino提供了几种ai的封装好的开发模式，例如muli-agent，react 当然，目前eino也支持了集成mcp，因此，我们的代码中要做的更多就是设计方面的考虑，在实现上相对来说较为简单。\n项目流程 让我们梳理一下项目流程，首先，拿到知识点，然后给llm，让他帮我们画即可，然后把生成的内容保存。\n这非常简单，但我们需要引入下列能力：\n联网搜索，让llm可以获得到最新的知识点（因此本项目可以对近期的热点事件进行思维导图的绘制），且避免出现幻觉。使用方法，eino提供了搜索的工具，比如google、duckduckgo，我们用他的duckduckgo提供搜索服务。 绘制思维导图的能力，我们用到了mindmap-mcp-server 我们可以手动保存文件，也可以让ai保存，为了演示mcp的用法，我们用@modelcontextprotocol/server-filesystem来实现llm对文件的操作 Mcp调用部分 首先，我们的配置文件需要自主配置mcp，以支持mcp的拓展，因此我们采用了以下格式:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 { \u0026#34;mcps\u0026#34;: [ { \u0026#34;command\u0026#34;: \u0026#34;uvx\u0026#34;, \u0026#34;env\u0026#34;: [], \u0026#34;args\u0026#34;: [ \u0026#34;mindmap-mcp-server\u0026#34;, \u0026#34;--return-type\u0026#34;, \u0026#34;html\u0026#34; ] }, { \u0026#34;command\u0026#34;: \u0026#34;npx\u0026#34;, \u0026#34;env\u0026#34;: [], \u0026#34;args\u0026#34;: [ \u0026#34;-y\u0026#34;, \u0026#34;@modelcontextprotocol/server-filesystem\u0026#34;, \u0026#34;填上运行项目的地址！！！\u0026#34; ] } ] } 写在配置文件里，这与市面上大部分三方MCP的设置形式都是相同的，加载mcp的代码如下，其实就是将mcp全部转换成了tool call。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; einomcp \u0026#34;github.com/cloudwego/eino-ext/components/tool/mcp\u0026#34; \u0026#34;github.com/cloudwego/eino/components/tool\u0026#34; \u0026#34;github.com/mark3labs/mcp-go/client\u0026#34; \u0026#34;github.com/mark3labs/mcp-go/mcp\u0026#34; ) func GenerateTools() []tool.BaseTool { startTime := time.Now() ctx := context.Background() var res []tool.BaseTool initRequest := mcp.InitializeRequest{} initRequest.Params.ProtocolVersion = mcp.LATEST_PROTOCOL_VERSION initRequest.Params.ClientInfo = mcp.Implementation{ Name: \u0026#34;mind-maker-client\u0026#34;, Version: \u0026#34;1.0.0\u0026#34;, } for _, item := range ActivateConfig.Mcps { cli, e := client.NewStdioMCPClient(item.Command, item.Env, item.Args...) if e != nil { panic(e) } _, e = cli.Initialize(ctx, initRequest) if e != nil { panic(e) } // 将mcp转换为工具 tools, e := einomcp.GetTools(ctx, \u0026amp;einomcp.Config{ Cli: cli, }) if e != nil { panic(e) } res = append(res, tools...) } timeLast := time.Since(startTime) fmt.Println(\u0026#34;生成mcp工具列表用时:\u0026#34;, timeLast) return res } 大模型调用部分 由于eino已经支持了react模式，因此我们直接拿过来用即可，因此要设计的核心点是prompt，目前项目中的prompt如下\n1 2 下面，你需要对用户给出的知识点进行思维导图的绘制，然后将结果保存在mind.html，要求思维导图结构清晰，逻辑正确，覆盖面广，生成的内容的语言应当使用中文 制作前你需要进行搜索收集相关信息，如果收集到的信息不是中文，请翻译成中文，结果一定要是中文，记住，一定要将结果保存到mind.html，生成的内容的语言应当使用中文 主要做的内容其实也就是对语言的限制，以及嘱咐ai记得调用相关能力。\n完整调用过程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 package main import ( \u0026#34;bufio\u0026#34; \u0026#34;context\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/cloudwego/eino-ext/components/model/openai\u0026#34; \u0026#34;github.com/cloudwego/eino-ext/components/tool/duckduckgo\u0026#34; \u0026#34;github.com/cloudwego/eino/compose\u0026#34; \u0026#34;github.com/cloudwego/eino/flow/agent\u0026#34; \u0026#34;github.com/cloudwego/eino/flow/agent/react\u0026#34; \u0026#34;github.com/cloudwego/eino/schema\u0026#34; ) func main() { ctx := context.Background() fmt.Println(\u0026#34;mind-maker by dinglz\u0026#34;) fmt.Println(\u0026#34;https://github.com/dingdinglz/mind-maker\u0026#34;) LoadConfig() if FileExist(\u0026#34;mind.html\u0026#34;) { os.Remove(\u0026#34;mind.html\u0026#34;) } fmt.Print(\u0026#34;请输入要生成思维导图的知识点:\u0026#34;) reader := bufio.NewReader(os.Stdin) question, e := reader.ReadString(\u0026#39;\\n\u0026#39;) if e != nil { panic(e) } question = strings.ReplaceAll(question, \u0026#34; \u0026#34;, \u0026#34;\u0026#34;) question = strings.ReplaceAll(question, \u0026#34;\\n\u0026#34;, \u0026#34;\u0026#34;) fmt.Println(\u0026#34;开始对知识点\u0026#34;, question, \u0026#34;绘制思维导图\u0026#34;) chatModel, e := openai.NewChatModel(ctx, \u0026amp;openai.ChatModelConfig{ BaseURL: ActivateConfig.Model.BaseURL, APIKey: ActivateConfig.Model.ApiKey, Model: ActivateConfig.Model.Model, }) if e != nil { panic(e) } tools := GenerateTools() ducktool, e := duckduckgo.NewTool(ctx, \u0026amp;duckduckgo.Config{}) if e != nil { panic(e) } tools = append(tools, ducktool) ragent, e := react.NewAgent(ctx, \u0026amp;react.AgentConfig{ Model: chatModel, ToolsConfig: compose.ToolsNodeConfig{ Tools: tools, }, }) if e != nil { panic(e) } startTime := time.Now() sr, e := ragent.Stream(ctx, []*schema.Message{ { Role: schema.System, Content: \u0026#34;下面，你需要对用户给出的知识点进行思维导图的绘制，然后将结果保存在mind.html，要求思维导图结构清晰，逻辑正确，覆盖面广，生成的内容的语言应当使用中文\\n\\n制作前你需要进行搜索收集相关信息，如果收集到的信息不是中文，请翻译成中文，结果一定要是中文，记住，一定要将结果保存到mind.html，生成的内容的语言应当使用中文\u0026#34;, }, { Role: schema.User, Content: question, }, }, agent.WithComposeOptions(compose.WithCallbacks(\u0026amp;LoggerCallback{}))) if e != nil { panic(e) } defer sr.Close() for { msg, e := sr.Recv() if e != nil { if errors.Is(e, io.EOF) { break } panic(e) } fmt.Print(msg.Content) } fmt.Println() fmt.Println(\u0026#34;生成思维导图用时：\u0026#34;, time.Since(startTime)) if FileExist(\u0026#34;mind.html\u0026#34;) { fmt.Println(\u0026#34;生成思维导图已保存到：mind.html\u0026#34;) } else { fmt.Println(\u0026#34;生成失败！请重试\u0026#34;) } } 总结 这只是一个相当于一个简单的llm集成mcp的示例 + eino的示例，完整代码请去github查看\n结语 近期拿到了一个生成ui原型图的prompt，还挺有意思的，也挺强，基于此开发了个ui原型图生成的网页，有时间就发篇blog唠唠\n","date":"2025-04-29T02:00:00Z","permalink":"https://dingdinglz.github.io/p/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E7%BB%98%E5%88%B6mcp%E7%89%88/","title":"思维导图绘制（mcp版）"},{"content":"概述 由于我曾经对ai写代码这一概念并不是很认同，觉得他会很快从历史舞台上推出，因此并没有在cursor刚出的时候就体验（事实证明我是对的，强的是agent而不是chat），但随着claude以及gemini新模型的不断发布，似乎vibe编程越来越热，加上国产大厂字节的trae也开始加入市场，直接引爆了我的好奇心。\n所以，我亲身体验了cursor和trae，先上结论\n结论 对于已有idea，快速成型，trae和cursor均有非常强的能力，能理解人的需求，并能在一定程度上读懂网页上的文档或者markdown文档。（似乎可以进行某些优化，让文档变成ai更易懂的方式），但是，生成的代码并不易读 此外，生成的代码项目结构意识并不强，通常只会生成几个文件，然后堆积一大堆代码（可以理解，涉及到工具调用，尽量减少调用次数），但是，这就导致代码质量极速下降，很多代码仅仅是为了完成功能，并没有考虑复用性和性能问题，生成大量重复的代码，例如前端部分不用layout统一做界面，每个子界面都把layout重新生成一遍，目前有prompt对于该问题做了提升，但还是不尽人意 对于现有成体系的代码，新增功能或者修改bug的能力并不强，尤其是项目文件较多的时候，可能与上下文长度限制有关，而且，新增的代码代码风格并不能与老代码对齐，增加了审核和修改的难度 所以，短期内，重要的项目仍然选择手敲的形式比较好，我甚至刻意地去关闭tab，避免ai的思路对我造成干扰 但是，一些需要快速完成的项目（比如拿到ppt上展示），生成原型图等，ai ide就可以完全发挥出他的功力，这一部分可能我也只需要他完成功能即可，后期不需要额外修改，不需要上线，也不需要注意他的代码质量 这里是我的建议！！！\n新手请慎重使用AI IDE，你应该清楚代码在做什么，只让AI写会迷失你自己，这不能让你的coding水平得到任何的提升 AI完成代码后，对于重要的部分，一定要review一遍！一定要review一遍！ 让AI这颗子弹再飞一会，不行我们先自己code吧，相信你的生产力！ 下面是对两款IDE的评测\nTrae Features Bad Points 暂时效果上仍然不如cursor（同模型下对比），期待字节持续发力 排队等待AI响应时间过长 这几天失去了对vscode插件市场的支持，导致开发时需要开启两个IDE（trae + vscode 一个生成一个写） Good Points 界面对中文用户更加友好，我觉得相比于cursor更加美观（也可能是理工男审美发力了） 目前已经支持agent模式，支持mcp，甚至还自带了一个mcp市场 界面截图 Cursor Features Bad Points 收费，20美刀一个月 mcp配置对新手来说较难，但是使用AI IDE的同志可能都是开发者？所以涉及到该产品的定位如何。 Good Points 代码生成结果和审美相较于trae有显著提高 支持agent + mcp 对vscode插件兼容性好，就算不用ai功能，也可以当成vscode使用 界面截图 ","date":"2025-04-28T02:00:00Z","permalink":"https://dingdinglz.github.io/p/ai-ide%E6%9D%82%E8%B0%88/","title":"AI IDE杂谈"},{"content":"什么是mcp MCP 是一种开放协议，通过标准化的服务器实现，使 AI 模型能够安全地与本地和远程资源进行交互。此列表重点关注可用于生产和实验性的 MCP 服务器，这些服务器通过文件访问、数据库连接、API 集成和其他上下文服务来扩展 AI 功能。\nmcp最近如此之火，已经成为这几天llm界最大的话题（不是），市面上也涌现了一批功能强大，覆盖各个方面的mcp server，本文主要介绍如何调用这些mcp server，以及如何把mcp server集成到Eino（字节跳动开源的大模型应用开发框架）中，使我们的ai也可以调用mcp的能力。\nLet‘s start\n如何寻找mcp servers 这里有一份非常棒的mcp server列表，你可以寻找任何你想要的功能：https://github.com/punkpeye/awesome-mcp-servers\n另外，各大api厂商，在原有http api的基础上，陆续开放了mcp server，例如百度地图，更方便ai的接入\n下文，我们以https://github.com/blackwhite084/playwright-plus-python-mcp为例，进行mcp的调用，使用的client包是：https://github.com/mark3labs/mcp-go\n前置准备 现有的mcp servers大部分都是基于npx，uvx或者直接一个可执行文件，我们要用到的这个mcp server基于uvx，点我安装uv\nplaywright是一个浏览器自动化工具，playwright-plus-python-mcp基于其实现功能，点我安装playwright\nmcp server 构成 一个mcp server会提供一个tool list，也就是支持的能力，并介绍对应tool的功能和需要传入的参数，以及返回的参数\n获取tool list 根据文档，可以轻松的把获取tool list的功能写出来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/mark3labs/mcp-go/client\u0026#34; \u0026#34;github.com/mark3labs/mcp-go/mcp\u0026#34; ) func main() { c, err := client.NewStdioMCPClient( \u0026#34;uvx\u0026#34;, []string{}, \u0026#34;playwright-server\u0026#34;, ) if err != nil { log.Fatalf(\u0026#34;Failed to create client: %v\u0026#34;, err) } ctx := context.Background() initRequest := mcp.InitializeRequest{} initRequest.Params.ProtocolVersion = mcp.LATEST_PROTOCOL_VERSION initRequest.Params.ClientInfo = mcp.Implementation{ Name: \u0026#34;example-client\u0026#34;, Version: \u0026#34;1.0.0\u0026#34;, } initResult, err := c.Initialize(ctx, initRequest) if err != nil { log.Fatalf(\u0026#34;Failed to initialize: %v\u0026#34;, err) } fmt.Printf( \u0026#34;Initialized with server: %s %s\\n\\n\u0026#34;, initResult.ServerInfo.Name, initResult.ServerInfo.Version, ) fmt.Println(\u0026#34;Listing available tools...\u0026#34;) toolsRequest := mcp.ListToolsRequest{} tools, err := c.ListTools(ctx, toolsRequest) if err != nil { log.Fatalf(\u0026#34;Failed to list tools: %v\u0026#34;, err) } for _, tool := range tools.Tools { fmt.Printf(\u0026#34;- %s: %s\\n\u0026#34;, tool.Name, tool.Description) } fmt.Println() } 主要的流程也就是新建一个mcp的client，然后指定连接的方式，然后进行初始化，获取到工具列表\n可以看到，支持的功能如下：\n1 2 3 4 5 6 7 8 - playwright_navigate: Navigate to a URL,thip op will auto create a session - playwright_screenshot: Take a screenshot of the current page or a specific element - playwright_click: Click an element on the page using CSS selector - playwright_fill: Fill out an input field - playwright_evaluate: Execute JavaScript in the browser console - playwright_click_text: Click an element on the page by its text content - playwright_get_text_content: Get the text content of all elements - playwright_get_html_content: Get the HTML content of the page 当然，这部分的内容在mcp-server的文档中也可以查询到\n利用mcp server实现截图特定网页 那么，让我们利用这些tool实现一个简单的功能，对github.com进行截图，我们需要用到两个tool，playwright_navigate和playwright_screenshot，也就是先导航到对应网站，再进行截图，实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 package main import ( \u0026#34;context\u0026#34; \u0026#34;encoding/base64\u0026#34; \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/mark3labs/mcp-go/client\u0026#34; \u0026#34;github.com/mark3labs/mcp-go/mcp\u0026#34; ) func main() { c, err := client.NewStdioMCPClient( \u0026#34;uvx\u0026#34;, []string{}, \u0026#34;playwright-server\u0026#34;, ) if err != nil { log.Fatalf(\u0026#34;Failed to create client: %v\u0026#34;, err) } ctx := context.Background() initRequest := mcp.InitializeRequest{} initRequest.Params.ProtocolVersion = mcp.LATEST_PROTOCOL_VERSION initRequest.Params.ClientInfo = mcp.Implementation{ Name: \u0026#34;example-client\u0026#34;, Version: \u0026#34;1.0.0\u0026#34;, } initResult, err := c.Initialize(ctx, initRequest) if err != nil { log.Fatalf(\u0026#34;Failed to initialize: %v\u0026#34;, err) } fmt.Printf( \u0026#34;Initialized with server: %s %s\\n\\n\u0026#34;, initResult.ServerInfo.Name, initResult.ServerInfo.Version, ) fmt.Println(\u0026#34;Listing available tools...\u0026#34;) toolsRequest := mcp.ListToolsRequest{} tools, err := c.ListTools(ctx, toolsRequest) if err != nil { log.Fatalf(\u0026#34;Failed to list tools: %v\u0026#34;, err) } for _, tool := range tools.Tools { fmt.Printf(\u0026#34;- %s: %s\\n\u0026#34;, tool.Name, tool.Description) } fmt.Println() navigateRequest := mcp.CallToolRequest{} navigateRequest.Params.Name = \u0026#34;playwright_navigate\u0026#34; navigateRequest.Params.Arguments = map[string]interface{}{ \u0026#34;url\u0026#34;: \u0026#34;https://github.com/\u0026#34;, } result, err := c.CallTool(ctx, navigateRequest) if err != nil { log.Fatalf(\u0026#34;Failed to navigate: %v\u0026#34;, err) } printToolResult(result) jRequest := mcp.CallToolRequest{} jRequest.Params.Name = \u0026#34;playwright_screenshot\u0026#34; jRequest.Params.Arguments = map[string]interface{}{ \u0026#34;name\u0026#34;: \u0026#34;test.png\u0026#34;, } result, err = c.CallTool(ctx, jRequest) if err != nil { log.Fatalf(\u0026#34;Failed to navigate: %v\u0026#34;, err) } printToolResult(result) image := result.Content[0].(mcp.ImageContent) resPng, _ := base64.StdEncoding.DecodeString(image.Data) os.WriteFile(\u0026#34;test.png\u0026#34;, resPng, os.ModePerm) } func printToolResult(result *mcp.CallToolResult) { for _, content := range result.Content { if textContent, ok := content.(mcp.TextContent); ok { fmt.Println(textContent.Text) } else { jsonBytes, _ := json.MarshalIndent(content, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) fmt.Println(string(jsonBytes)) } } } 通过mcp.CallToolRequest进行调用，可以看到，返回的调用结果是mcp.Content的形式，根据文档的说明可以转成mcp.TextContent，mcp.ImageContent等等\n运行完后本地的test.png图片已经保存：\n回顾 上述利用mcp-server的能力简单实现了一个浏览器自动化的例子，如果吧这个mcp server接入到ai中，允许llm使用的话，可以实现一系列浏览器自动化操作，像cursor等等以及支持了mcp协议的引入，让我们看看go中如何与外部llm集成，也就是利用eino框架，让mcp去代替原有的function calling的功能。\neino引入 官方引入介绍：Tool - MCP | CloudWeGo\neino原本实现类似langchain的功能相对来说就比较轻松，官方给出的mcp接入方法感觉像是把mcp的tools转换成了原本的function tool。\n通过：\n1 2 3 import \u0026#34;github.com/cloudwego/eino-ext/components/tool/mcp\u0026#34; tools, err := mcp.GetTools(ctx, \u0026amp;mcp.Config{Cli: cli}) 然后再把tools加入Tool Node节点，就能跟以前的function call一样去使用mcp，也算是给出了一种简洁的接入方法吧\n本文主要介绍mcp，就不再赘述eino的使用方式了\n结尾 咕咕爽啊（不是），有时间再详细介绍一下eino框架吧，golang自己的langchain\n","date":"2025-03-29T02:00:00Z","permalink":"https://dingdinglz.github.io/p/mcp-with-golang/","title":"Mcp with golang"},{"content":" 伟大的etcd构成了云原生的基石\n什么是etcd etcd 是由 CoreOS（现为 Red Hat 旗下）开发的分布式键值存储系统，采用 Go 语言编写。它通过 Raft 共识算法实现高可用性，专为分布式系统设计，提供以下核心能力：\n强一致性：保证所有节点数据状态完全一致\n高可用性：通过多节点集群自动故障转移\n简单易用：通过 HTTP API 提供 RESTful 接口\n可扩展性：支持水平扩展和动态集群管理\n在分布式系统领域，etcd 以其优雅的设计和强大的功能，成为云原生时代的基础设施基石。它就像一个\u0026quot;分布式系统的心脏\u0026quot;，为 Kubernetes、Service Mesh 等系统提供核心的分布式数据管理能力。\netcd的实际应用 为分布式系统提供配置设置中心，也就是键值对存储，有点类似于redis，下面我们会谈到它和redis的异同\n实现配置的热更新，也就是利用etcd的watch功能监听键值的变化\n作为分布式锁的一种实现形式\n作为微服务中，服务发现与注册中心（得益于lease和watch）\n下面，我们将针对这些实际应用，将golang代码实现结合来进行讲解\n在此之前，先完成前置准备工作：\n前置工作 安装etcd：Install | etcd\n本文go实现代码基于ectd官方client包：etcd/client/v3 at main · etcd-io/etcd · GitHub\nLet\u0026rsquo;s start\n部署 etcd支持单机部署和集群式部署，集群式部署时，etcd保证了自己不同终端间的数据高度一致性和高度可用性，也就是说，与redis相比，etcd更加一致，同步速度更快，因而作为分布式配置同步是很好的选择\n由于本文主要谈一谈etcd能帮我们实现哪些内容，就不在此详细说明如何部署etcd集群（让运维哥去头疼吧哈哈哈），想要了解详细内容可以参考：How to Set Up a Demo etcd Cluster | etcd\nGolang连接etcd 首先安装前置工作中的etcd官方的client包，然后参考下述代码进行连接，即可得到一个etcd的client对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;fmt\u0026#34; etcd \u0026#34;go.etcd.io/etcd/client/v3\u0026#34; ) func main() { client, e := etcd.New(etcd.Config{ Endpoints: []string{ \u0026#34;localhost:2379\u0026#34;, }, }) if e != nil { fmt.Println(e.Error()) return } 键值对的读和写 etcd最基础的功能其实就是做一个kv存储，有点类似于redis，但是etcd并不具备redis那样丰富的数据类型，所以存储和读取时的结构只有string-string。更多拓展可以考虑用json格式去封装\n写 1 2 ctx := context.Background() client.Put(ctx, \u0026#34;test\u0026#34;, \u0026#34;test-value\u0026#34;) 这样即给test设置了值\n读 1 2 3 4 5 6 7 8 res, e := client.Get(ctx, \u0026#34;test\u0026#34;) if e != nil { fmt.Println(e.Error()) return } for _, item := range res.Kvs { fmt.Println(string(item.Key) + \u0026#34;:\u0026#34; + string(item.Value)) } 这样即可以取到key和value\n大家可能有疑惑为什么res.Kvs是一个切片而不是一个元素，因为Get可以按前缀读\n按前缀读 1 2 3 4 5 6 7 8 res, e := client.Get(ctx, \u0026#34;test\u0026#34;, etcd.WithPrefix()) if e != nil { fmt.Println(e.Error()) return } for _, item := range res.Kvs { fmt.Println(string(item.Key) + \u0026#34;:\u0026#34; + string(item.Value)) } 可以看到区别仅仅在于etcd.WithPrefix()，这句的意思就是读所有前缀是test的键值对，有点类似于test*，我们如果新建一个test2和test3，用上述代码可以全部读出来\n键值对的合租（lease） 所谓lease，可以理解成一个键的保质期，lease用于与键进行绑定，一个lease可以绑定多个键，当lease过期时，对应的键都会被删除。\n与正常的过期时间不同的是，lease可以被续时或者直接销毁。\n基于以上特点，让我们想想lease可以拿来做什么：\n配合监听机制去做心跳包，也就是设置一个过期时间，让服务器端不断的去维护（延时）lease，如果服务器宕机了，与lease绑定的键会自动删除，也就说明了这台服务器对应的已经不可用\n根据上面那点可以继续拓展，做微服务的服务注册，比如一个api对应一个ip，让服务器动态维护ip的更新，服务器寄了也就导致这个api失效\n设置过期时间 1 2 3 4 // 创建一个新的lease，过期时间是5s lease, _ := client.Grant(ctx, 5) // 将刚刚创建的lease与键绑定 client.Put(ctx, \u0026#34;test\u0026#34;, \u0026#34;test-lease\u0026#34;, etcd.WithLease(lease.ID)) 大家可以试一下5s后再去取test这个键，这个时候test已经被删除\n服务器维护心跳包 1 2 3 4 5 6 7 8 9 // 创建一个新的lease，过期时间是5s lease, _ := client.Grant(ctx, 5) // 将刚刚创建的lease与键绑定 client.Put(ctx, \u0026#34;heart-ping\u0026#34;, \u0026#34;live\u0026#34;, etcd.WithLease(lease.ID)) for { // 留1s给网络因素 time.Sleep(4 * time.Second) client.KeepAliveOnce(ctx, lease.ID) } 此时，验证服务器是否存活只需要验证heart-ping是否存在即可\n监听键值对（watch） 实时监听键值对的变化，根据这个功能可以做到配置的热更新等等\n1 2 3 4 5 6 7 8 9 10 11 // 监听test键 watcher := client.Watch(ctx, \u0026#34;test\u0026#34;) for event := range watcher { for _, item := range event.Events { if item.Type == etcd.EventTypeDelete { fmt.Println(string(item.Kv.Key) + \u0026#34; deleted\u0026#34;) } else { fmt.Println(string(item.Kv.Key) + \u0026#34; changed:\u0026#34; + string(item.Kv.Value)) } } } 类似的，watch也接受etcd.WithPrefix()参数\n分布式锁 既然redis可以维护一个分布式锁，那么我etcd当然也行，并且同步性更强，更易于拓展\n分布式锁的原理 通过redis、etcd这些中间件，让一把锁可以被多个应用共用，实现原理也很简单，维护一个键的存在作为锁被占用，不存在作为未加锁的状态去实现，例如使用redis的SETNX\n分布式锁想要实现的功能与本地的sync.MXLock这些基本类似，区别仅仅在于前者允许多个系统同时访问\n实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 开启一个事务 res, _ := client.Txn(ctx).If(etcd.Compare(etcd.CreateRevision(\u0026#34;lock\u0026#34;), \u0026#34;=\u0026#34;, \u0026#34;0\u0026#34;)). // 如果lock不存在，即为可以加锁 Then( etcd.OpPut(\u0026#34;lock\u0026#34;, \u0026#34;1\u0026#34;), // 创建lock占用锁 ). Commit() if res.Succeeded { // 加锁成功 // do someting .... // 解锁 client.Delete(ctx, \u0026#34;lock\u0026#34;) } else { fmt.Println(\u0026#34;加锁失败，占用中\u0026#34;) } 为了不形成死锁，也就是一直保持占用状态，可以通过设置ctx的timeout或者用刚刚说的lease去维护一个过期时间来处理\n加锁失败的情况也不代表彻底不能使用，只是当前被占用，可以用循环尝试多次上锁等等操作\n服务发现与治理 比如说，一个rpc服务，有个function，调用的ip地址有多个，通过心跳包实时维护他的地址，通过watch去动态更新调用的地址，如果你想要深入了解这方面，可以去阅读go-zero的相关部分的源码，它的默认实现就是利用etcd\netcd与redis的异同 特性 Redis etcd 核心功能 高性能键值存储系统，支持多种数据结构（字符串、列表、哈希、集合、有序集合等）。 分布式一致性键值存储系统，专注于服务发现、配置管理、分布式协调。 数据模型 支持丰富的数据类型，如字符串、列表、哈希、集合、有序集合、位图、地理空间等。 仅支持简单的键值对（字符串），但支持版本控制、租约（Lease）和目录结构（递归操作）。 一致性模型 支持最终一致性（异步复制）或强一致性（通过 Redis Cluster 或多主模式）。 通过 Raft 协议保证强一致性，所有节点数据实时同步。 性能 高吞吐量和低延迟，适合高频读写操作（如缓存、队列）。 为一致性牺牲部分性能，但能满足分布式系统协调需求。 持久化 支持 RDB（快照）和 AOF（追加日志）两种持久化方式。 数据持久化基于 Raft 日志，支持 WAL（预写日志）和快照。 适用场景 缓存、队列、实时计数器、会话管理、消息中间件（如 Redis Pub/Sub）。 服务发现、配置中心、分布式锁、 leader 选举、分布式状态协调（如 Kubernetes）。 一致性协议 不依赖特定协议，通过主从复制或 Cluster 实现分布式。 基于 Raft 协议实现分布式一致性，确保所有节点数据一致。 集群管理 需要额外工具（如 Redis Cluster、Redis Sentinel）实现高可用。 内置集群管理，自动故障转移和节点发现。 API 接口 原生协议（Redis Protocol）或 RESTful API（通过 RedisJSON 等模块扩展）。 原生 HTTP/JSON API，支持 Watch 机制（实时监听键值变化）。 生态系统 丰富的客户端库（支持多种语言）、插件和扩展模块（如 RedisModule）。 提供官方客户端库（Go、Java、Python 等），专注于分布式协调场景。 部署复杂度 单机部署简单，集群模式需配置主从或 Cluster。 需要集群部署（至少 3 个节点），但管理相对自动化。 典型用途示例 缓存高频访问数据、实现消息队列（如 Celery）、实时计数器（如限流）。 存储分布式系统的配置、服务注册与发现、协调分布式任务（如 etcd 作为 Kubernetes 的存储后端）。 写在最后 在咕咕了很久之后终于又更新了一篇（），etcd在目前谈啥都要聊聊分布式的年代（虽然或许其实不需要用分布式也能带得动呢，真的有那么多用户吗？）起着很重要的作用，etcd在这个领域也不是一家独大，它的“同行”有zookeeper等等，但显然etcd是其中格外出色的。\n顺便一提，最近有种很忙又不知道在忙啥的感觉（），希望下次更新可以提上日程吧，尚且咕咕了一篇kmp和eino的内容，唉唉唉\n","date":"2025-03-24T02:00:00Z","permalink":"https://dingdinglz.github.io/p/etcd%E7%9A%84%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%BA%94%E7%94%A8/","title":"etcd的功能与应用"},{"content":"Geospatial Redis地理空间索引可用于存储地理坐标并支持基于坐标的检索功能。这种数据结构适用于查找给定半径或边界框范围内的邻近位置点，在定位周边目标场景中具有重要应用价值。\n其实我感觉这是个挺奇怪的类型，地理坐标似乎只对特定业务有用，其实就是一个pair\u0026lt;double,double\u0026gt;的set，附带了一些计算方法和筛选方法。\nGEOADD 将一个位置添加到地理空间里，用法是GEOADD 地理空间名 经度 纬度 地点名\nredis-cli 1 GEOADD test -122.27652 37.805186 station:1 go-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \u0026#34;context\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) client.GeoAdd(ctx, \u0026#34;test\u0026#34;, \u0026amp;redis.GeoLocation{ Name: \u0026#34;station:1\u0026#34;, Longitude: -122.27652, Latitude: 37.805186, }) } GEODIST 可以获取两点间的距离，用法是GEODIST 地理空间名 地点1 地点2\nredis-cli 1 GEODIST test station:1 station:2 km km可以替换成其他长度，例如m\ngo-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) res, e := client.GeoDist(ctx, \u0026#34;test\u0026#34;, \u0026#34;station:1\u0026#34;, \u0026#34;station:2\u0026#34;, \u0026#34;m\u0026#34;).Result() if e != nil { panic(e) } fmt.Println(res) } GEOPOS 获取地理空间中一个点的坐标，用法是GEOPOS 地理空间名 地点名\nredis-cli 1 GEOPOS test station:1 go-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) res, e := client.GeoPos(ctx, \u0026#34;test\u0026#34;, \u0026#34;station:1\u0026#34;).Result() if e != nil { panic(e) } fmt.Println(res[0]) } GEOSEARCH 搜索一个圆或者一个长方形内的地理位置的个数，用法是GEOSEARCH 地理空间名 \u0026lt;FROMMEMBER member | FROMLONLAT longitude latitude\u0026gt; \u0026lt;BYRADIUS radius \u0026lt;M | KM | FT | MI\u0026gt; | BYBOX width height \u0026lt;M | KM | FT | MI\u0026gt;\u0026gt;\nredis-cli 1 GEOSEARCH test FROMLONLAT -122.2612767 37.7936847 BYRADIUS 5 km WITHDIST go-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) res, e := client.GeoSearch(ctx, \u0026#34;test\u0026#34;, \u0026amp;redis.GeoSearchQuery{ Longitude: -122.2612767, Latitude: 37.7936847, Radius: 5, RadiusUnit: \u0026#34;km\u0026#34;, }).Result() if e != nil { panic(e) } for _, i := range res { fmt.Println(i) } } 回顾 地理空间对于某些特定业务非常有用，例如地图中的定位，搜索等等，我们今天聊了这些命令：\nGEOADD\nGEODIST\nGEOPOS\nGEOSEARCH\n更多地理空间相关的命令\n","date":"2025-02-24T02:00:00Z","permalink":"https://dingdinglz.github.io/p/redis%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%857-geospatial/","title":"Redis学习之旅(7) Geospatial"},{"content":"Stream Redis流是一种数据结构，其行为类似于仅追加日志，同时实现了多项突破常规仅追加日志局限性的操作。这些特性包括支持常量时间复杂度(O(1))的随机访问，以及实现诸如消费者组等复杂的消息消费策略。通过流结构，开发者能够实时记录并同步分发事件。其典型应用场景包括：\n事件溯源（例如跟踪用户操作、点击等行为）\n传感器监测（例如来自现场设备的读数数据）\n通知功能（例如为每位用户的通知记录单独创建独立事件流存储）\n流是一个非常强大的类型，因此它的特性也就非常复杂，首先流可以理解成一个列表，但是其中的每个元素是带有先后顺序的一个Hash表，流与之前提到的List相比，最突出的一个特性是监听，通过消费者组，可以去实时地收到流中传来的最新的消息（或者未处理的消息）\n因此，流比List更适合实现消息队列\nXADD XADD用于向流中添加一个元素，注意，这个元素是一个hash表的形式，所以它类似于map[string]interface{}，XADD的用法是XADD 流名 ID key value ...\nXADD会返回一个ID对应这个元素，XADD中的id你即可以手动指定（需要注意的是，你添加的元素一定要比上一次添加的元素的ID新），或者用*让redis自动帮你生成，redis生成的id是和时间相绑定的\n比如我们要往person流中添加一个人，这个人具有name、age这两个字段\nredis-cli 1 XADD person * name dinglz age 18 go-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;context\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) client.XAdd(ctx, \u0026amp;redis.XAddArgs{ Stream: \u0026#34;person\u0026#34;, ID: \u0026#34;*\u0026#34;, Values: map[string]interface{}{ \u0026#34;name\u0026#34;: \u0026#34;dinglz\u0026#34;, \u0026#34;age\u0026#34;: 18, }, }) } XDEL 删除流中的一个元素，用法是XDEL 流名 ID\nredis-cli 1 XDEL person ID go-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( \u0026#34;context\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) client.XDel(ctx, \u0026#34;person\u0026#34;, \u0026#34;id\u0026#34;) } XRANGE 按范围查询流的内容，用法是XRANGE 流名 开始 结束 [COUNT 获取个数]\n[]内是可选内容，开始id和结束id有一个特殊写法，就是-和+，前者代表最老一个流内容，后者代表最新一个流内容，也就是说，要获取刚刚流里所有内容，我们就可以XRANGE person - +\n如果我们想获取最初加入的三个元素，我们就可以用COUNT限定最多取到的元素个数，可以这么写：XRANGE person - + COUNT 3\n如果我们一直一个ID，想获取它的内容，我们就可以XRANGE person id id\ngo-redis example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) res, e := client.XRange(ctx, \u0026#34;person\u0026#34;, \u0026#34;-\u0026#34;, \u0026#34;+\u0026#34;).Result() if e != nil { panic(e) } for _, i := range res { fmt.Println(i) } } XGROUP CREATE 新建一个监听组，用法是XGROUP CREATE 流名 组名 开始监听的id, 这个id可以填成$，表示监听从新建以后新增的id。\n配合下面要说的XREADGROUP命令可以完成对消息的监听\nXREADGROUP 从监听的流里获取新消息，用法是XREADGROUP GROUP 监听组名 监听者 COUNT 最多获取消息数 STREAMS 流名 \u0026gt;\n最后一个\u0026gt;表示获取从来没有被其他监听者听到过的消息，也就保证了消息不会重复分发\n下面我们来添加三个人，然后尝试获取两次次\nredis-cli 1 2 3 4 5 6 XGROUP CREATE person test $ XADD person * name dinglz age 18 XADD person * name jack age 20 XADD person * name alice age 22 XREADGROUP GROUP test listener COUNT 1 STREAMS person \u0026gt; XREADGROUP GROUP test listener COUNT 1 STREAMS person \u0026gt; 可以看到是从新到老获取\ngo-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) client.XGroupCreateMkStream(ctx, \u0026#34;person\u0026#34;, \u0026#34;test\u0026#34;, \u0026#34;$\u0026#34;) client.XAdd(ctx, \u0026amp;redis.XAddArgs{ Stream: \u0026#34;person\u0026#34;, ID: \u0026#34;*\u0026#34;, Values: map[string]interface{}{ \u0026#34;name\u0026#34;: \u0026#34;dinglz\u0026#34;, \u0026#34;age\u0026#34;: 18, }, }) client.XAdd(ctx, \u0026amp;redis.XAddArgs{ Stream: \u0026#34;person\u0026#34;, ID: \u0026#34;*\u0026#34;, Values: map[string]interface{}{ \u0026#34;name\u0026#34;: \u0026#34;jack\u0026#34;, \u0026#34;age\u0026#34;: 20, }, }) client.XAdd(ctx, \u0026amp;redis.XAddArgs{ Stream: \u0026#34;person\u0026#34;, ID: \u0026#34;*\u0026#34;, Values: map[string]interface{}{ \u0026#34;name\u0026#34;: \u0026#34;alice\u0026#34;, \u0026#34;age\u0026#34;: 20, }, }) res, e := client.XReadGroup(ctx, \u0026amp;redis.XReadGroupArgs{ Group: \u0026#34;test\u0026#34;, Consumer: \u0026#34;listener\u0026#34;, Streams: []string{\u0026#34;person\u0026#34;, \u0026#34;\u0026gt;\u0026#34;}, Count: 1, }).Result() if e != nil { panic(e) } fmt.Println(res[0].Messages[0].Values) } XACK \u0026amp;\u0026amp; XPENDING XACK和XPENDING是一组命令，XPENDING用于获取被获取，但没被处理的流里的数据，XACK用于标记该数据已被处理。\nXPENDING的用法是XPENDING 流名 监听组名，XACK的用法是XACK 流名 监听组名 ID\n详细的用法直接参考用例吧\n用例 这里我们用stream实现一个更完善的消息队列，实现了以下功能\n三个workers去认领任务\n三个workers一共最多拥有十个处理任务的goroutine\n每3s做一次剩余任务量的通报\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) var waitGroup sync.WaitGroup var processLock sync.Mutex func taskMaker(ctx context.Context, client *redis.Client, counts int) { for i := 1; i \u0026lt;= counts; i++ { client.XAdd(ctx, \u0026amp;redis.XAddArgs{ Stream: \u0026#34;tasks\u0026#34;, Values: map[string]interface{}{ \u0026#34;name\u0026#34;: \u0026#34;task\u0026#34; + strconv.Itoa(i), }, }) } } func workerMaker(ctx context.Context, client *redis.Client, name string) { for { resW, _ := client.XReadGroup(ctx, \u0026amp;redis.XReadGroupArgs{ Group: \u0026#34;worker\u0026#34;, Consumer: name, Count: 1, Streams: []string{\u0026#34;tasks\u0026#34;, \u0026#34;\u0026gt;\u0026#34;}, Block: 1 * time.Second, }).Result() if len(resW) == 0 { fmt.Println(name + \u0026#34;认领工作完成\u0026#34;) break } go func() { for { processLock.Lock() res, _ := client.Get(ctx, \u0026#34;worker-count\u0026#34;).Int() if res \u0026lt; 10 { client.Incr(ctx, \u0026#34;worker-count\u0026#34;) go func() { max := int64(3 * time.Second) ns := rand.Int63n(max) time.Sleep(time.Duration(ns)) client.XAck(ctx, \u0026#34;tasks\u0026#34;, \u0026#34;worker\u0026#34;, resW[0].Messages[0].ID) client.XDel(ctx, \u0026#34;tasks\u0026#34;, resW[0].Messages[0].ID) fmt.Println(resW[0].Messages[0].Values[\u0026#34;name\u0026#34;], \u0026#34;由\u0026#34;, name, \u0026#34;完成\u0026#34;) client.Decr(ctx, \u0026#34;worker-count\u0026#34;) }() processLock.Unlock() break } processLock.Unlock() } }() } } func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) client.Set(ctx, \u0026#34;worker-count\u0026#34;, 0, 0) go taskMaker(ctx, client, 100) client.XGroupCreateMkStream(ctx, \u0026#34;tasks\u0026#34;, \u0026#34;worker\u0026#34;, \u0026#34;$\u0026#34;) waitGroup.Add(1) for i := 1; i \u0026lt;= 3; i++ { go workerMaker(ctx, client, \u0026#34;worker\u0026#34;+strconv.Itoa(i)) } go func() { for { time.Sleep(3 * time.Second) res, _ := client.XPending(ctx, \u0026#34;tasks\u0026#34;, \u0026#34;worker\u0026#34;).Result() resText := \u0026#34;\u0026#34; for name, last := range res.Consumers { resText += name + \u0026#34;:\u0026#34; + strconv.FormatInt(last, 10) + \u0026#34; \u0026#34; } fmt.Println(resText) if res.Count == 0 { waitGroup.Done() } } }() waitGroup.Wait() } 回顾 Stream非常强大，从我们上面实现的消费队列就可以看出，大家可以详细研究一下Stream相关的，我们未提到的其他命令，今天聊到了这些命令：\nXADD\nXDEL\nXRANGE\nXGROUP CREATE\nXREADGROUP\nXACK \u0026amp;\u0026amp; XPENDING\n更多stream相关的命令\n","date":"2025-02-23T02:00:00Z","permalink":"https://dingdinglz.github.io/p/redis%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%856-streams/","title":"Redis学习之旅(6) Streams"},{"content":"Sorted Sets Redis有序集合是一种由唯一字符串（成员）构成的数据结构，其成员按关联分值排序。当多个字符串具有相同分值时，这些字符串将按字典顺序排列。其典型应用场景包括：\n排行榜。例如，在大型在线游戏中，您可以通过有序集合轻松维护最高分的有序列表，实现高效的游戏积分排名系统。\n速率限制器。特别是可以利用有序集合构建滑动窗口速率限制器，以防止过多的API请求。\nsorted set与set的区别是，它与set一样都是只能存放互异的元素，但是它的每个元素与一个分数（score）绑定。\nsorted set有点类似于cpp的stl中的优先队列，他会将所有元素按照score的大小进行排序\nZADD 向sorted set中加入一个元素，用法是ZADD 有序集合名 元素的分数 元素\n当我们要修改一个元素的分数时，可以直接再用一遍ZADD，会自动修改元素的分数并重新排序\nredis-cli 1 ZADD age 20 jack go-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;context\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) client.ZAdd(ctx, \u0026#34;age\u0026#34;, redis.Z{ Member: \u0026#34;Jack\u0026#34;, Score: 20, }) } ZREM 从sorted set中删除一个元素，用法是ZREM 有序集合名 元素\nredis-cli 1 ZREM age jack go-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( \u0026#34;context\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) client.ZRem(ctx, \u0026#34;age\u0026#34;, \u0026#34;Jack\u0026#34;) } ZRANGE \u0026amp;\u0026amp; ZREVRANGE 遍历sorted set，ZRANGE是以升序方式遍历，ZREVRANGE是以降序方式遍历\n用法是ZRANGE 排序集合名 开始下标 结束下标\n比如ZRANGE age 0 -1就是升序方式遍历整个集合（从小分数到大分数），ZREVRANGE则与之相反\nredis-cli 1 2 3 4 ZADD age 18 dinglz ZADD age 20 jack ZADD age 25 alice ZRANGE age 0 -1 得到的结果是\n1 2 3 1) \u0026#34;dinglz\u0026#34; 2) \u0026#34;jack\u0026#34; 3) \u0026#34;alice\u0026#34; 可以看到是从小到大遍历的，大家可以自己试一下ZREVRANGE\ngo-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) res, e := client.ZRange(ctx, \u0026#34;age\u0026#34;, 0, -1).Result() if e != nil { panic(e) } for _, i := range res { fmt.Println(i) } } ZRANK \u0026amp;\u0026amp; ZREVRANK 获取排序集合中一个元素从小到大的排名（REV从大到小），用法是ZRANK 排序集合名 元素，注意，获取到的排名从0开始\nredis-cli 1 ZRANK age dinglz go-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) res, e := client.ZRank(ctx, \u0026#34;age\u0026#34;, \u0026#34;dinglz\u0026#34;).Result() if e != nil { panic(e) } fmt.Println(res) } ZRANGEBYSCORE \u0026amp;\u0026amp; ZREVRANGEBYSCORE 与ZRANGE类似，但是ZRANGEBYSCORE限制了score的范围，用法是ZRANGEBYSCORE 排序集合名 最小分数 最大分数和ZREVRANGEBYSCORE 排序集合名 最大分数 最小分数\n注意！！这两个命令的最小分数和最大分数位置是相反的\n比如，我们要获取年龄从小到大，从最小到20的排序\nredis-cli 1 ZRANGEBYSCORE age -inf 20 inf指无穷大，-inf就是无穷小\ngo-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) res, e := client.ZRangeByScore(ctx, \u0026#34;age\u0026#34;, \u0026amp;redis.ZRangeBy{ Min: \u0026#34;-inf\u0026#34;, Max: \u0026#34;20\u0026#34;, }).Result() if e != nil { panic(e) } for _, i := range res { fmt.Println(i) } } 回顾 从上面一些命令就可以看出，sorted sets简直就是为了排行榜这种而生的，当你的服务想引入排行榜时，我们借助它就能轻易实现，今天聊到了这些命令：\nZADD\nZREM\nZRANGE \u0026amp;\u0026amp; ZREVRANGE\nZRANK \u0026amp;\u0026amp; ZREVRANK\nZRANGEBYSCORE \u0026amp;\u0026amp; ZREVRANGEBYSCORE\n","date":"2025-02-22T02:00:00Z","permalink":"https://dingdinglz.github.io/p/redis%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%855-sorted-sets/","title":"Redis学习之旅(5) Sorted sets"},{"content":"Hashes Redis hashes是一种记录类型，结构为字段值对的集合。\n你可以使用 hashes 来\n表示基本对象\n存储计数器的分组等\n我感觉Hash有点类似于map[string]interface{}\nhash可以存储这种类似的json\n1 2 3 4 { \u0026#34;name\u0026#34;:\u0026#34;dinglz\u0026#34;, \u0026#34;age\u0026#34;:18 } 简单的来说，一个hash类型的值，存储的是key-value的结构\nHSET 设置一个字段的值，用法是HSET hash名 字段名 字段值\n比如要存储一个人的信息，存储他的姓名和年龄，我们就可以\n1 2 HSET person name dinglz HSET person age 18 go-redis example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;context\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) client.HSet(ctx, \u0026#34;person\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;dinglz\u0026#34;) client.HSet(ctx, \u0026#34;person\u0026#34;, \u0026#34;age\u0026#34;, 18) } HGET 获取某个字段的值，用法是HGET hash名 字段名\nredis-cli 1 HGET person name go-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) res, e := client.HGet(ctx, \u0026#34;person\u0026#34;, \u0026#34;name\u0026#34;).Result() if e != nil { panic(e) } fmt.Println(res) } HINCRBY 与INCRBY类似，让hash的某个字段增加一个数值，用法是HINCRBY hash名 字段名 增加的数值\n比如要模拟一个人长大了一岁\nredis-cli 1 HINCRBY person age 1 go-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( \u0026#34;context\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) client.HIncrBy(ctx, \u0026#34;person\u0026#34;, \u0026#34;age\u0026#34;, 1) } HEXISTS 判断hash中是否存在某个字段，用法是HEXISTS hash名 字段名\nredis-cli 1 HEXISTS person name go-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) res, e := client.HExists(ctx, \u0026#34;person\u0026#34;, \u0026#34;name\u0026#34;).Result() if e != nil { panic(e) } fmt.Println(res) } HKEYS 可以获取hash中的所有字段，用法是HKEYS hash名\nredis-cli 1 HKEYS person go-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) res, e := client.HKeys(ctx, \u0026#34;person\u0026#34;).Result() if e != nil { panic(e) } for _, i := range res { fmt.Println(i) } } 回顾 HASHES就是一个高性能，可持久化的map，今天聊到了这些命令：\nHSET \u0026amp;\u0026amp; HGET\nHINCRBY\nHEXISTS\nHKEYS\n更多Hash相关的命令\n","date":"2025-02-21T02:00:00Z","permalink":"https://dingdinglz.github.io/p/redis%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%854-hash/","title":"Redis学习之旅(4) Hash"},{"content":"Sets Redis集合是一种由唯一字符串成员构成的无序集合，这个集合就很接近大家认识里的集合了，与c++ stl中的set类似，但是多支持了很多功能。注意：Sets和数组的差异在于Sets内的每个元素一定是互异的。\n通过集合，你可以：\n追踪唯一性数据（例如记录访问某篇博客文章的所有独立IP地址）\n描述对象间关联关系（例如具有特定角色的全体用户集合）\n执行常见的集合运算，包括交集、并集与差集操作。\nSADD 将一个元素添加到集合中，用法是：SADD [集合名] 值，注意，如果这个值与集合中之前存在的元素重复，将不会重复添加，添加多个元素是允许的，比如SADD test 1 2 3 4 5 6\nredis-cli 1 SADD test 1 go-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( \u0026#34;context\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) client.SAdd(ctx, \u0026#34;test\u0026#34;, \u0026#34;1\u0026#34;) } SREM 删除集合中的一个元素，用法是：SREM [集合名] 值\n删除多个元素也是允许的。\nredis-cli 1 SREM test 1 go-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( \u0026#34;context\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) client.SRem(ctx, \u0026#34;test\u0026#34;, \u0026#34;1\u0026#34;) } SISMEMBER 判断元素在不在SET里，用法是：SISMEMBER [集合名] 值\nredis-cli 1 SISMEMBER test 1 go-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) res, e := client.SIsMember(ctx, \u0026#34;test\u0026#34;, \u0026#34;1\u0026#34;).Result() if e != nil { panic(e) } fmt.Println(res) } SCARD 获取集合中元素的个数，高中时大家应该就学过card(X) = 集合X的个数，就是这个CARD，记法就是set_card。用法是：SCARD 集合名\nredis-cli 1 SCARD test go-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) res, e := client.SCard(ctx, \u0026#34;test\u0026#34;).Result() if e != nil { panic(e) } fmt.Println(res) } SINTER 这是一个很有意思的命令，可以取两个集合的交集\n比如，我有两个集合，test和test2，分别有1，2，3，4和1，3，4，5这些元素\nSINTER test test2可以取得1，3，4也就是这两个集合的交集\nredis-cli 1 SINTER test test2 go-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) res, e := client.SInter(ctx, \u0026#34;test\u0026#34;, \u0026#34;test2\u0026#34;).Result() if e != nil { panic(e) } for _, i := range res { fmt.Println(i) } } SDIFF 这个命令用于求两个集合的差，也是一个比较有意思的命令，如果是SDIFF setA setB的话，给我的感觉像是setA - SINTER(setA setB)\nredis-cli 1 SDIFF test test2 go-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) res, e := client.SDiff(ctx, \u0026#34;test\u0026#34;, \u0026#34;test2\u0026#34;).Result() if e != nil { panic(e) } for _, i := range res { fmt.Println(i) } } SUNION 求两个集合的并集\nredis-cli 1 SUNION test test2 go-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) res, e := client.SUnion(ctx, \u0026#34;test\u0026#34;, \u0026#34;test2\u0026#34;).Result() if e != nil { panic(e) } for _, i := range res { fmt.Println(i) } } SMEMBERS 获取一个集合的全部成员\nredis-cli 1 SMEMBERS test go-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) res, e := client.SMembers(ctx, \u0026#34;test\u0026#34;).Result() if e != nil { panic(e) } for _, i := range res { fmt.Println(i) } } SRANDMEMBER 这也是个很有意思的功能，从集合中随机抽元素，用法是SRANDMEMBER set名 个数，个数是可选的参数，如果不填个数的话默认抽一个\n这个功能感觉可以拿来做抽奖小程序啊（如果完全随机的话）\ngo-redis example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) res, e := client.SRandMemberN(ctx, \u0026#34;test\u0026#34;, 2).Result() if e != nil { panic(e) } for _, i := range res { fmt.Println(i) } } SPOP 这个命令用于随机从集合中抽取一个元素并把它删除，这种场景我有点难想象，假如有个不重复抽取的奖池（抽完为止，奖池里奖品数固定）就可以用这个命令抽取。\nredis-cli 1 SPOP test go-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) res, e := client.SPop(ctx, \u0026#34;test\u0026#34;).Result() if e != nil { panic(e) } fmt.Println(res) } 示例 我们就用SPOP来实现一个抽奖小程序吧\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{}) for i := 1; i \u0026lt;= 10; i++ { // 添加十个奖品 client.SAdd(ctx, \u0026#34;test\u0026#34;, \u0026#34;prize\u0026#34;+strconv.Itoa(i)) } for { res, e := client.SPop(ctx, \u0026#34;test\u0026#34;).Result() if e != nil { if e == redis.Nil { fmt.Println(\u0026#34;抽取完成！\u0026#34;) break } panic(e) } fmt.Println(\u0026#34;抽到了\u0026#34;, res, \u0026#34;!\u0026#34;) } } 回顾 SET感觉可以当作数组来用，今天聊到这里讲了这些命令：\nSADD\nSREM\nSISMEMBER\nSCARD\nSINTER \u0026amp;\u0026amp; SDIFF \u0026amp;\u0026amp; SUNION\nSMEMBERS\nSRANDMEMBER\nSPOP\n更多SET相关的命令\n","date":"2025-02-16T03:00:00Z","permalink":"https://dingdinglz.github.io/p/redis%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%853-sets/","title":"Redis学习之旅(3) Sets"},{"content":"Lists Redis中的列表（Lists）是由字符串值构成的链表结构。\n相比于大家认知中的列表，我觉得这个格式更偏向于队列和栈，而不是数组\nRedis的列表通常用于：\n构建队列和栈\n为后台 worker 系统构建队列管理\n为什么这么说呢，首先对于Lists取出元素的操作大都是从一头取（如果看成一个双头队列的话），取出以后就删除该元素，这很显然就是典型的队列和栈的结构（大家可能也知道，cpp的stl中的栈是由deque实现的），那么下面介绍一下Lists相关的命令\nLPUSH \u0026amp;\u0026amp; RPUSH 我建议在理解redis的lists结构时将它看成一个线性的结构，一条横铺的线，那么LPUSH就是从左边插入元素（Left Push），RPUSH就是从右边插入元素（Right Push），按这么来记，对于下文中讲的其他R和L开头的命令来说会更好理解一点。\nLPUSH和RPUSH于SET的使用方法类似，形如：LPUSH 列表名 要插入的值或者RPUSH 列表名 要插入的值，下面我们再讲R或者L开头的命令时可能就不再重复阐述，只讲解R或者L的命令。\nLPUSH会在List不存在的时候自动创建List，因而不要在意\n需要注意的是，LPUSH可以依次插入多个元素，例如LPUSH tasks 1 2 3 4 5是正确的。\n下面我们举个例子，比如创建一个任务列表tasks\nredis-cli 1 2 LPUSH tasks task1 LPUSH tasks task2 go-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;context\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{ Addr: \u0026#34;localhost:6379\u0026#34;, }) client.LPush(ctx, \u0026#34;tasks\u0026#34;, \u0026#34;task1\u0026#34;) client.LPush(ctx, \u0026#34;tasks\u0026#34;, \u0026#34;task2\u0026#34;) } LPOP \u0026amp;\u0026amp; RPOP 继续沿用我们刚刚的思想，就是分别从左边和右边弹出一个元素，但是，这里的POP和我们c++的stl中队列的pop不同的是，它并不简简单单只是删除，而是附带了一个取回的操作。\n比如我们LPOP tasks，就能得到task2，RPOP同理\ngo-redis example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{ Addr: \u0026#34;localhost:6379\u0026#34;, }) res, e := client.LPop(ctx, \u0026#34;tasks\u0026#34;).Result() if e != nil { panic(e) } fmt.Println(res) } LLEN 获取列表的长度，只需要LLEN 列表名即可，例如：LLEN tasks\ngo-redis example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{ Addr: \u0026#34;localhost:6379\u0026#34;, }) res, e := client.LLen(ctx, \u0026#34;tasks\u0026#34;).Result() if e != nil { panic(e) } fmt.Println(res) } LRANGE 从左边开始获取一个范围到右边的某个位置，range嘛，用法是：LRANGE 列表名 左边坐标 右边坐标，就可以获取到从[左边坐标，右边坐标]这个范围的所有元素，注意，这个坐标从左边开始数，且从零开始。（让我很奇怪的是，这个命令为什么没有R版，也就是说RRANGE是不存在的）\n另外，右边坐标可以= -1，这时候代表从左边坐标一直取到最右边，类似于go的切片留空，和py、matlab的-1，其实这里的-1代表的是从另一头数第一个元素，也就是从右侧开始数第一个元素，同理，-2代表从另一头数第二个元素\nredis-cli 1 2 3 4 LPUSH test 1 LPUSH test 2 LPUSH test 3 LRANGE test 0 1 得到：\n1 2 1) \u0026#34;3\u0026#34; 2) \u0026#34;2\u0026#34; go-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{ Addr: \u0026#34;localhost:6379\u0026#34;, }) client.LPush(ctx, \u0026#34;test\u0026#34;, 1) client.LPush(ctx, \u0026#34;test\u0026#34;, 2) client.LPush(ctx, \u0026#34;test\u0026#34;, 3) res, e := client.LRange(ctx, \u0026#34;test\u0026#34;, 0, 1).Result() if e != nil { panic(e) } for _, i := range res { fmt.Println(i) } } 示例 下面让我们用go-redis利用List模拟一下消息队列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) var waitGroup sync.WaitGroup // 向消息队列中添加任意个待处理的任务 func AddTasks(ctx context.Context, client *redis.Client, num int) { for i := 1; i \u0026lt;= num; i++ { client.LPush(ctx, \u0026#34;tasks\u0026#34;, \u0026#34;task\u0026#34;+strconv.Itoa(i)) } } // 处理消息队列 func DealTasks(ctx context.Context, client *redis.Client, name string) { //先添加的任务先处理 for { task, e := client.RPop(ctx, \u0026#34;tasks\u0026#34;).Result() if e == redis.Nil { fmt.Println(name + \u0026#34;处理完成！\u0026#34;) waitGroup.Done() break } fmt.Println(name + \u0026#34;处理\u0026#34; + task + \u0026#34;中\u0026#34;) // 模拟处理耗时 dealTime := rand.Intn(3001) time.Sleep(time.Duration(dealTime) * time.Millisecond) } } func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{ Addr: \u0026#34;localhost:6379\u0026#34;, }) waitGroup.Add(3) AddTasks(ctx, client, 100) for i := 1; i \u0026lt;= 3; i++ { // 开三个goroutine来处理 go DealTasks(ctx, client, \u0026#34;处理通道\u0026#34;+strconv.Itoa(i)) } waitGroup.Wait() } 可以看到，得益于redis的单线程，我们虽然开了三个线程开同时处理消息列表中的任务，仍然可以保证先进来的任务先被处理。\n朋友们可以自己修改一下进程数和任务数，并体会一下如何把这个简单的消息队列运用到实战中\n限制 Redis 列表的最大长度为 2^32 - 1 （4,294,967,295） 个元素。\n回顾 今天说到这里差不多把Lists的一些常用命令说完了，还附带了一个小小的应用例子，让我们来回顾一下今天学习了哪些命令\nLPUSH \u0026amp;\u0026amp; RPUSH\nLPOP \u0026amp;\u0026amp; RPOP\nLLEN\nLRANGE\n更多Lists相关的命令\n","date":"2025-02-16T02:00:00Z","permalink":"https://dingdinglz.github.io/p/redis%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%852-lists/","title":"Redis学习之旅(2) Lists"},{"content":"前言 （其实是本系列的前言）\n为什么又开新坑了：因为学学redis，顺便同时记录下cli和go-redis的操作\n为什么老坑不更了（或者没更完）：不想写了 没人看\n说正事：\n本系列会对每个命令同时讲解两方面：redis-cli的操作和go-redis的操作，尽量完成官网上文档对应命令的100% 代码覆盖率\n本系列大部分内容参考：官网文档：Develop with Redis | Docs\n本文讲的是，redis广大类型中最常见的一个：Strings\n前前言 （补充一下redis的介绍）\nRedis 是什么？\nRedis（Remote Dictionary Server）是一个开源的 内存数据库，它以超快的读写速度和灵活的数据结构著称。你可以把它想象成一个“超级加速器”，专门用来存储那些需要频繁访问的数据（比如网站热门内容、用户登录信息），或者用来解决高并发场景下的性能瓶颈。\nRedis 的三大特点\n内存存储\n数据直接放在内存中，读写速度极快（微秒级），远超传统硬盘数据库（如 MySQL）。\n丰富的数据结构\n除了简单的键值对（Key-Value），还支持：\n字符串（String）：缓存文本、数字 哈希表（Hash）：存储对象（如用户信息） 列表（List）：实现消息队列 集合（Set）/ 有序集合（Sorted Set）：去重、排行榜 更多高级结构如位图（Bitmaps）、地理坐标（GEO）等。 持久化与高可用\n虽然数据在内存中，但 Redis 支持定期保存到硬盘（RDB 快照）或记录操作日志（AOF），防止断电丢失。还能通过主从复制、哨兵模式、集群模式保障服务稳定。\n典型使用场景\n缓存层：减轻数据库压力，加速网页加载。 会话存储：快速管理用户登录状态。 实时排行榜：游戏积分、热搜榜单。 消息队列：异步处理任务（如发送邮件）。 秒杀系统：应对瞬时高并发请求。 为什么选择 Redis？\n简单易用：命令简洁（例如 SET name \u0026quot;Alice\u0026quot;、GET name）。 跨语言支持：Python、Java、Go 等主流语言均可调用。 生态强大：大量企业级扩展方案（集群、监控工具等）。 小提示\nRedis 虽强，但并非万能：\n内存成本较高，不适合存储海量冷数据。 适合高速读写场景，复杂计算仍需传统数据库。 String 总而言之，Redis就是一个KV数据库，你可以把它理解成golang中的map[string]interface{} , 我们类型篇就将着手于对于V - Value的类型的介绍。\nRedis字符串可存储字节序列，包括文本、序列化对象及二进制数组。因此，字符串是可与Redis键关联的最基本数据类型。它们不仅常用于缓存场景，还支持更多高级功能，如实现计数器及执行位运算，展现出多样化的应用潜力。\n由于Redis的键均为字符串类型，当值也采用字符串类型时，我们实际上是将一个字符串映射至另一个字符串。这种字符串数据类型适用于多种应用场景，例如缓存HTML片段或页面。\nSET \u0026amp;\u0026amp; GET SET看这个翻译应该也能明白大概的意思，就是一个设置，给定一个Key和一个Value来存储。\n比如：SET key value就能存储，有点像map里map[key] = value\n存储完成以后自然可以通过key去查询，用我们的GET指令GET key\n下面的例子是用redis-cli去存储并查询一个自行车的名字\n1 2 SET bike:name name GET bike:name 这个例子中：bike:name就是key，name就是value，大家可以打开自己的redis-cli动手敲一敲\ngo-redis example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{ Addr: \u0026#34;localhost:6379\u0026#34;, }) client.Set(ctx, \u0026#34;bike:name\u0026#34;, \u0026#34;name\u0026#34;, 0) res, e := client.Get(ctx, \u0026#34;bike:name\u0026#34;).Result() if e != nil { panic(e) } fmt.Println(res) } 大家可能会好奇为什么go-redis的Set跟redis-cli的SET相比多了个参数，这就是我们接下来要说的expire\nExpire 也就是过期时间，redis的SET是支持设置过期时间的，而0也就代表着没有过期时间，即永不过期，那么过期时间的作用是什么呢，是规定该数据最多只能存放这么长时间。\nredis-cli设置过期时间的方法是SET key value EX [time]，time是过期时间的长度，是一个数字，单位是秒。go-redis只需要将0修改为time类型的值即可，例如：1*time.Second\nMSET \u0026amp;\u0026amp; MGET 这两个命令其实就是SET和GET的升级版，用于设置和获取多个数据，直接来看例子吧\nredis-cli 1 2 MSET bike:1 test1 bike:2 test bike:3 test MGET bike:1 bike:2 bike:3 上述命令输出的结果是：\n1 2 3 1) \u0026#34;test1\u0026#34; 2) \u0026#34;test\u0026#34; 3) \u0026#34;test\u0026#34; go-redis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{ Addr: \u0026#34;localhost:6379\u0026#34;, }) client.MSet(ctx, \u0026#34;bike:1\u0026#34;, \u0026#34;test1\u0026#34;, \u0026#34;bike:2\u0026#34;, \u0026#34;test2\u0026#34;, \u0026#34;bike:3\u0026#34;, \u0026#34;test3\u0026#34;) res, e := client.MGet(ctx, \u0026#34;bike:1\u0026#34;, \u0026#34;bike:2\u0026#34;, \u0026#34;bike:3\u0026#34;).Result() if e != nil { panic(e) } for _, i := range res { fmt.Println(i) } } INCR \u0026amp;\u0026amp; DECR 这两个命令把字符串值解析成数，并分别进行自增和自减，使用的方式也很简单，INCR key和DECR key即可\n比如：\n1 2 3 4 5 SET test 3 INCR test GET test DECR test GET test 两次GET分别得到4和3，也就是自增一次，然后自减一次，有趣的是，这两个命令都是原子的，也就是说你可以任意地在并发里调用他们而不会出问题，这得益于redis的单线程机制\ngo-redis example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{ Addr: \u0026#34;localhost:6379\u0026#34;, }) client.Set(ctx, \u0026#34;test\u0026#34;, 3, 0) client.Incr(ctx, \u0026#34;test\u0026#34;) res, _ := client.Get(ctx, \u0026#34;test\u0026#34;).Int() fmt.Println(res) client.Decr(ctx, \u0026#34;test\u0026#34;) res, _ = client.Get(ctx, \u0026#34;test\u0026#34;).Int() fmt.Println(res) } INCRBY \u0026amp;\u0026amp; DECRBY 与上述两个命令基本相同，只是多了指定增减的数目，比如\n1 2 3 4 5 SET test 2 INCRBY test 3 GET test DECRBY test 1 GET test 两次GET分别输出5和4\ngo-redis example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/redis/go-redis/v9\u0026#34; ) func main() { ctx := context.Background() client := redis.NewClient(\u0026amp;redis.Options{ Addr: \u0026#34;localhost:6379\u0026#34;, }) client.Set(ctx, \u0026#34;test\u0026#34;, 2, 0) client.IncrBy(ctx, \u0026#34;test\u0026#34;, 3) res, _ := client.Get(ctx, \u0026#34;test\u0026#34;).Int() fmt.Println(res) client.DecrBy(ctx, \u0026#34;test\u0026#34;, 1) res, _ = client.Get(ctx, \u0026#34;test\u0026#34;).Int() fmt.Println(res) } String的限制 默认情况下，单个 Redis 字符串的最大大小为 512 MB。\n回顾 今天说到这里差不多就把Strings常见的命令说完了，我们说了：\nSET \u0026amp;\u0026amp; GET\nMSET \u0026amp;\u0026amp; MGET\nINCR \u0026amp;\u0026amp; DECR\nINCRBY \u0026amp;\u0026amp; DECRBY\n更多Strings相关的命令\n","date":"2025-02-15T02:00:00Z","permalink":"https://dingdinglz.github.io/p/redis%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%851-strings/","title":"Redis学习之旅(1) Strings"},{"content":"概述 微服务概述 近几年微服务的概念非常火，各大大厂也都已经在很多项目上采用的微服务式的设计，相比于直接用中间件做负载均衡的设计，微服务的优点在于它的模块式开发，支持热更新，对分布式更加友好。\n对于一家大公司而言，模块式的开发，以及保持产品的稳定性及其重要，前者可以通过微服务设计，后者可以通过在分布式架构下，找个用户量小的时间段分批次更新来做到。\n通常来说，微服务架构由很多微服务（负责实现不同的功能）和一个中心网关来实现，中心网关负责做负载均衡和服务治理，以及其他的统一处理请求。每个单一的微服务提供不同的功能。\n大家较为熟知的rpc就是中心网关与微服务直接沟通的方式之一。\n那么，想要实现一个微服务架构的应用要考虑的点非常之多，包括服务治理，负载均衡，熔断，主从同步等等内容。我也因此很长时间对于微服务的了解只停留在概念阶段。\n近期参与到知易项目的开发中，便决定采用微服务架构，在一次次尝试中，发现了本文要介绍的非常好用，让开发者专注于逻辑的微服务框架go-zero\ngo-zero概述 go-zero是一个集成了各种工程实践的 web 和 rpc 框架。通过弹性设计保障了大并发服务端的稳定性，经受了充分的实战检验。\n也就是说，你能想到要实现的所有功能，已经完全被内置在了go-zero这个框架中。\n本文实战内容概述 我们用书店服务做示例，并且实现其中的增加书目和检查价格这两个功能，来模拟实际项目开发的流程。\n那么，Let\u0026rsquo;s go!!\n环境准备 安装golang 上官网或者镜像站下载即可，别忘记配置go package的代理\n可用的一个代理：七牛云\n安装mysql 我们通过mysql作为数据库来存储图书。\n我推荐直接使用docker的mysql镜像来启动mysql，便于管理。\n也可以在本机安装mysql，安利下之前我开发过的一款mysql管理工具：MysqlManager: 可视化管理mysql，新建库，删除库，更改密码，初始化mysql，启动，关闭等日常操作。\n安装etcd 我们用etcd作为服务发现中心，etcd是一款go开发的高性能的配置中心\nReleases · etcd-io/etcd · GitHub 下载并运行即可\n安装protoc-gen-go rpc协议的代码生成器，用下面的代码安装即可\n1 go get -u github.com/golang/protobuf/protoc-gen-go@v1.3.2 安装goctl goctl是go-zero提供的一款代码生成工具，用于生成go-zero框架的代码，加速开发速度\n1 go get -u github.com/zeromicro/go-zero/tools/goctl@latest 创建目录 下面创建一个目录bookstore\n在目录中执行go mod init命令初始化项目\n1 go mod init bookstore 编写中心网关 在上一步中我们安装了goctl，我们可以通过生成并编写api文件，来让goctl帮我们生成代码，迅速的把微服务的框架大家起来。\n创建api文件 首先，创建api文件夹并进入，在文件夹下执行\n1 goctl api -o bookstore.api 可以看到目录下已经新建了bookstore.api文件。\n编辑它，我们把该项目的api设计为如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 type ( addReq { book string `form:\u0026#34;book\u0026#34;` price int64 `form:\u0026#34;price\u0026#34;` } addResp { ok bool `json:\u0026#34;ok\u0026#34;` } ) type ( checkReq { book string `form:\u0026#34;book\u0026#34;` } checkResp { found bool `json:\u0026#34;found\u0026#34;` price int64 `json:\u0026#34;price\u0026#34;` } ) service bookstore-api { @handler AddHandler get /add (addReq) returns (addResp) @handler CheckHandler get /check (checkReq) returns (checkResp) } type用法和go一致，service用来定义get/post/head/delete等api请求，解释如下：\nservice bookstore-api {这一行定义了service名字 @handler定义了服务端handler名字 get /add(addReq) returns(addResp)定义了get方法的路由、请求参数、返回参数等 api文件的具体语法可以前往官网查看。\n点我，点我查看具体语法\n然后我们就可以使用goctl为我们一键式生成代码\n生成网关代码 1 goctl api go -api bookstore.api -dir . 生成的文件结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 api ├── bookstore.api // api定义 ├── bookstore.go // main入口定义 ├── etc │ └── bookstore-api.yaml // 配置文件 └── internal ├── config │ └── config.go // 定义配置 ├── handler │ ├── addhandler.go // 实现addHandler │ ├── checkhandler.go // 实现checkHandler │ └── routes.go // 定义路由处理 ├── logic │ ├── addlogic.go // 实现AddLogic │ └── checklogic.go // 实现CheckLogic ├── svc │ └── servicecontext.go // 定义ServiceContext └── types └── types.go // 定义请求、返回结构体 此时网关便是符合我们api文件中声明的结构。\n你可以直接在api文件夹go build来生成网关的可执行文件\n如果遇到依赖相关的报错，记得go mod tidy更新下依赖哦\n总结 目前的这个中心网关并没有实现对应的功能，只是一个空壳子，下面让我们分别完成add和check这部分的微服务。\n编写微服务 add rpc服务 在bookstore下创建rpc目录。\n在rpc目录中分别创建add和check的文件夹。\n首先我们来编写add的服务声明，进入add文件夹中\n通过命令生成rpc声明的文件模版\n1 goctl rpc template -o add.proto 修改文件如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 syntax = \u0026#34;proto3\u0026#34;; package add; option go_package = \u0026#34;./add\u0026#34;; message addReq { string book = 1; int64 price = 2; } message addResp { bool ok = 1; } service adder { rpc add(addReq) returns(addResp); } 该文件是用来为grpc定义微服务传输的格式和相关信息。\n通过下面的命令生成rpc的代码\n1 goctl rpc protoc add.proto --go_out=. --go-grpc_out=. --zrpc_out=. 文件结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 rpc/add ├── add // pb.go │ ├── add.pb.go │ └── add_grpc.pb.go ├── add.go // main函数入口 ├── add.proto // proto源文件 ├── adder // rpc client call entry │ └── adder.go ├── etc // yaml配置文件 │ └── add.yaml └── internal ├── config // yaml配置文件对应的结构体定义 │ └── config.go ├── logic // 业务逻辑 │ └── addlogic.go ├── server // rpc server │ └── adderserver.go └── svc // 资源依赖 └── servicecontext.go 此时的add rpc已经编写完成，同样是可以go build并运行的\ncheck rpc服务 与add rpc服务想似\n1 goctl rpc template -o check.proto 修改check.proto如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 syntax = \u0026#34;proto3\u0026#34;; package check; option go_package = \u0026#34;./check\u0026#34;; message checkReq { string book = 1; } message checkResp { bool found = 1; int64 price = 2; } service checker { rpc check(checkReq) returns(checkResp); } 生成代码：\n1 goctl rpc protoc check.proto --go_out=. --go-grpc_out=. --zrpc_out=. etc/check.yaml文件里可以修改侦听端口等配置\n需要修改etc/check.yaml的端口为8081，因为8080已经被add服务使用了\n中心网关对接微服务 修改配置文件api/etc/bookstorrer-api.yaml，增加如下内容\n1 2 3 4 5 6 7 8 9 10 Add: Etcd: Hosts: - localhost:2379 Key: add.rpc Check: Etcd: Hosts: - localhost:2379 Key: check.rpc 通过etcd自动去发现可用的add/check服务\n修改api/internal/config/config.go如下，增加add/check服务依赖\n1 2 3 4 5 type Config struct { rest.RestConf Add zrpc.RpcClientConf // 手动代码 Check zrpc.RpcClientConf // 手动代码 } 修改api/internal/svc/servicecontext.go，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 type ServiceContext struct { Config config.Config Adder adder.Adder // 手动代码 Checker checker.Checker // 手动代码 } func NewServiceContext(c config.Config) *ServiceContext { return \u0026amp;ServiceContext{ Config: c, Adder: adder.NewAdder(zrpc.MustNewClient(c.Add)), // 手动代码 Checker: checker.NewChecker(zrpc.MustNewClient(c.Check)), // 手动代码 } } 修改api/internal/logic/addlogic.go里的Add方法，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func (l *AddLogic) Add(req *types.AddReq) (resp *types.AddResp, err error) { // 手动代码开始 r, err := l.svcCtx.Adder.Add(l.ctx, \u0026amp;adder.AddReq{ Book: req.Book, Price: req.Price, }) if err != nil { return nil, err } return \u0026amp;types.AddResp{ Ok: r.Ok, }, nil // 手动代码结束 } 通过调用adder的Add方法实现添加图书到bookstore系统\n修改api/internal/logic/checklogic.go里的Check方法，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func (l *CheckLogic) Check(req *types.CheckReq) (resp *types.CheckResp,err error) { // 手动代码开始 r, err := l.svcCtx.Checker.Check(l.ctx, \u0026amp;checker.CheckReq{ Book: req.Book, }) if err != nil { logx.Error(err) return \u0026amp;types.CheckResp{}, err } return \u0026amp;types.CheckResp{ Found: r.Found, Price: r.Price, }, nil // 手动代码结束 } 通过调用checker的Check方法实现从bookstore系统中查询图书的价格\n定义数据库表结构，并生成CRUD代码 好的，做到目前这一步，我们已经完成了中心网关的全部内容，下面我们就需要挨个实现add、check两个服务的具体功能。\n数据库操作无疑是主要的。\n让我们来定义数据库表结构，并生成CRUD代码\nbookstore下创建rpc/model目录\n定义表结构 在rpc/model目录下编写创建book表的sql文件book.sql，如下：\n1 2 3 4 5 6 CREATE TABLE `book` ( `book` varchar(255) NOT NULL COMMENT \u0026#39;book name\u0026#39;, `price` int NOT NULL COMMENT \u0026#39;book price\u0026#39;, PRIMARY KEY(`book`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 在mysql数据库中创建一个库，并运行这个sql文件建立表book\n通过goctl命令生成CRUD代码 rpc/model目录下执行该命令\n1 goctl model mysql ddl -c -src book.sql -dir . 生成后的文件结构如下：\n1 2 3 4 rpc/model ├── book.sql ├── bookstoremodel.go // CRUD+cache代码 └── vars.go // 定义常量和变量 amazing，curd的结构已经全部生成，我们只要调用即可。\nrpc中处理数据库 修改rpc/add/etc/add.yaml和rpc/check/etc/check.yaml，增加如下内容：\n1 2 DataSource: root:@tcp(localhost:3306)/gozero # mysql链接地址，满足 $user:$password@tcp($ip:$port)/$db?$queries 格式即可 修改rpc/add/internal/config/config.go和rpc/check/internal/config/config.go，如下：\n1 2 3 4 type Config struct { zrpc.RpcServerConf DataSource string // 手动代码 } 增加了mysql配置\n修改rpc/add/internal/svc/servicecontext.go和rpc/check/internal/svc/servicecontext.go，如下：\n1 2 3 4 5 6 7 8 9 10 11 type ServiceContext struct { c config.Config Model model.BookModel // 手动代码 } func NewServiceContext(c config.Config) *ServiceContext { return \u0026amp;ServiceContext{ c: c, Model: model.NewBookModel(sqlx.NewMysql(c.DataSource), c.Cache), // 手动代码 } } 修改rpc/add/internal/logic/addlogic.go，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func (l *AddLogic) Add(in *add.AddReq) (*add.AddResp, error) { // 手动代码开始 _, err := l.svcCtx.Model.Insert(l.ctx,\u0026amp;model.Book{ Book: in.Book, Price: in.Price, }) if err != nil { return nil, err } return \u0026amp;add.AddResp{ Ok: true, }, nil // 手动代码结束 } 修改rpc/check/internal/logic/checklogic.go，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 func (l *CheckLogic) Check(in *check.CheckReq) (*check.CheckResp, error) { // 手动代码开始 resp, err := l.svcCtx.Model.FindOne(l.ctx,in.Book) if err != nil { return nil,err } return \u0026amp;check.CheckResp{ Found: true, Price: resp.Price, }, nil // 手动代码结束 } 这几步是在调用数据库存储数据，所见即所得。\n测试 我们分别在add，check，api文件夹中运行go build\n生成了add.exe，check.exe，api.exe\n首先运行etcd，启动mysql\n再依次运行add，check和api（add和check运行顺序无所谓）即可启动服务\n让我们用curl调用测试一下\nadd 1 curl -i \u0026#34;http://localhost:8888/add?book=go-zero\u0026amp;price=10\u0026#34; 返回\n1 2 3 4 5 6 HTTP/1.1 200 OK Content-Type: application/json Date: Thu, 03 Sep 2020 09:42:13 GMT Content-Length: 11 {\u0026#34;ok\u0026#34;:true} 成功添加了一本书\ncheck 1 curl -i \u0026#34;http://localhost:8888/check?book=go-zero\u0026#34; 返回如下\n1 2 3 4 5 6 HTTP/1.1 200 OK Content-Type: application/json Date: Thu, 03 Sep 2020 09:47:34 GMT Content-Length: 25 {\u0026#34;found\u0026#34;:true,\u0026#34;price\u0026#34;:10} 成功查询到了这本书！\n本文所做项目的完整代码 zero-examples/bookstore at main · zeromicro/zero-examples · GitHub\n反思与总结 本文所做的事情其实仅仅是搭建了一个微服务的体系，然后实现了两个非常简单的功能\n真实的项目中需要完成完整的逻辑，并完成其他功能，比如redis缓存，限流器，鉴权等等，这些在go-zero中都为我们提供了现成的组件，不得不说，go-zero是一个强大的框架，同时，由于被众多公司用于真实项目，稳定性与安全性也是可以保障的。\n参考资料 zero-doc/docs/zero/bookstore.md at main · zeromicro/zero-doc · GitHub\nGo-zero\n","date":"2025-01-15T02:00:00Z","permalink":"https://dingdinglz.github.io/p/golang%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/","title":"Golang微服务实战"},{"content":"本文最终实现效果 搭建出一个在国内可访问的gemini api(符合openai api规范)，并绑定到自定义域名上。\n全文free of charge，伟大！感谢提供服务的公司们。\n如果不想手动部署的兄弟们，可以访问我部署好的api。\n1 https://gemini.dinglz.us.kg/v1 本文包含内容 在us.kg上注册一个域名并托管到cloudflare上\n部署openai-gemini到cloudflare workers上\n申请gemini apikey并测试可用性\n若已有域名并且已经托管到cloudflare上可以跳过第一步。\n注册域名 US.KG – A Free name for everyone 是一个为开发者们免费提供域名的网站，通过申请，你可以获得一个免费的\u0026quot;*.us.kg\u0026quot;的域名\n正如你所见，我的blog便是通过github pages部署在dinglz.us.kg上\n注册账号，并发送issue 进入上面的网址注册一个账号，然后按照要求为该平台的github项目点上star，并发送一个issue（网站内说明非常详细，在此不在赘述）\n创建域名 创建一个没被占用的域名\n前往cloudflare创建域名 Cloudflare | Web Performance \u0026amp; Security 进入该网站注册一个账号\n创建一个域\n输入刚刚注册的域名，点击继续，比如gemini.us.kg\n选择free计划\n点继续前往激活\n然后我们就能看到给我们提供的名称服务器\n将它们复制到刚刚创建域名所需要的Name Server1和Name Server2\n注册！\n在cloudflare中点击立即检查名称服务器，等待几分钟或者几小时后，即可在cloudflare里管理注册的域名，包括可以解析到你的服务器上，解析到github pages上等，我们下面的操作需要将该域名绑定到cloudflare worker上。\n你可能会遇到解析到自己的服务器上但无法使用的情况，这是因为国内服务器使用域名需要提前备案，域名备案后即可使用，本文无需进行备案（cloudflare是国外厂商，嘻嘻）\n部署openai-gemini 很好，目前为止我们已经成功白嫖了一个域名，并把它托管到了cloudflare上\n下面我们利用github-actions和cloudflare workers来创建我们的api\n首先打开该项目GitHub - PublicAffairs/openai-gemini: Gemini ➜ OpenAI API proxy. Serverless!\n往下划，找到deploy to cloudflare，deploy with workers按钮（本文只介绍cloudflare workers部署方法，托管到其他平台也是ok的，比如vercel，不过vercel同样不能在国内访问，不符合我们的使用需求）\n按照顺序往下即可\n其中获取account id和apikey都是cloudflare的\n这一步进行下说明。\naccount id 点进它提供给你的链接，右侧即可看到account id\n如果你看不到的话，随便创建一个workers，就能看到，获取到id后删了随便创建的即可。\napikey 点击创建令牌\n点击编辑 Cloudflare Workers的模版\n用户资源选择所有资源\n区域资源选择所有区域\n点击继续，即可获得apikey\n好的，完成上述步骤后，来到cloudflare workers面板，可以看到gemini服务已经成功部署啦！\n点进去，点击设置，添加一个域名\n添加的域名可以是你刚刚第一步托管进cloudflare的域名，也可以是该域名的子域名。\n祝贺！你添加的域名即为符合openai范式的api。\n调用并测试 好的，目前我们已经有了一个gemini的国内oepnai范式的api。\n下面我们需要申请一个gemini的apikey，Gemini 控制台，前往其中申请即可。\n下面让我们来调用吧。\n我之前为知易设计了一个调用支持openai范式的ai的微服务，我直接利用它进行测试\n太好了，我们成功了！\npy调用 顺便给出一个python调用的demo\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from openai import OpenAI client = OpenAI( api_key = \u0026#34;刚刚申请的gemini的apikey\u0026#34;, base_url = \u0026#34;https://你添加的域名/v1\u0026#34;, ) completion = client.chat.completions.create( model = \u0026#34;模型名\u0026#34;, messages = [ {\u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;提示词\u0026#34;}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;问题\u0026#34;} ], temperature = 0.3, ) print(completion.choices[0].message.content) 支持的模型列表 可以用获取模型列表的api查看，也可以上gemini的官网查看。\n参考资料 GitHub - PublicAffairs/openai-gemini: Gemini ➜ OpenAI API proxy. Serverless! 伟大的gemini转openai格式的api中间件，支持部署到各种托管平台上\ncloudflare 感谢伟大的cloudflare提供cloudflare workers\nUS.KG – A Free name for everyone 感谢伟大的us.kg为开发者们提供免费的域名\n【Cloudflare中转顶级大模型API，国内免费爽用，Gemini编程，音视频，多模态能力测试】 感谢伟大的博主分享出搭建方法，为本文提供基本思路\n","date":"2025-01-10T02:00:00Z","permalink":"https://dingdinglz.github.io/p/%E9%83%A8%E7%BD%B2%E5%9B%BD%E5%86%85gemini/","title":"部署国内gemini"},{"content":"简介 本文将借助Oh My Posh美化终端，有多款皮肤可选。\n最终大概能达到这个效果（一种）：\n注意：本文仅介绍powershell的安装方式，cmd、bash等可前往官网找到安装方式。\n安装 1 Set-ExecutionPolicy Bypass -Scope Process -Force; Invoke-Expression ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://ohmyposh.dev/install.ps1\u0026#39;)) 为了使 PATH 重新加载，建议重启您的终端。如果 oh-my-posh 未被识别为命令，您可以再次运行安装程序，或者手动将其添加到 PATH 中。例如：\n1 $env:Path += \u0026#34;;C:\\Users\\user\\AppData\\Local\\Programs\\oh-my-posh\\bin\u0026#34; 挑选皮肤 安装完成后，前往本页面挑选一款心仪的皮肤，将其下载下来，保存至一个JSON文件\n配置终端 打开终端脚本配置文件\n1 notepad $PROFILE 当上述命令出现错误时，请确保先创建配置文件，即执行下面的语句，顺利执行则不用执行下面的语句。\n1 New-Item -Path $PROFILE -Type File -Force 在打开的记事本的末尾加上\n1 oh-my-posh init pwsh --config \u0026#34;你刚刚下载下来的那个json文件的绝对地址\u0026#34; | Invoke-Expression 保存，并重启终端，你就能得到一个好看的终端啦。\nEnjoy it\n","date":"2024-12-17T02:00:00Z","permalink":"https://dingdinglz.github.io/p/powershell%E7%9A%84%E7%BE%8E%E5%8C%96/","title":"PowerShell的美化"},{"content":"什么是JWT jwt，全称JSON Web Token，是一种开放标准（RFC 7519），用于在网络应用环境间安全地传输信息。这些信息可以被验证和信任，因为它们是数字签名的。JWT可以使用秘密（使用HMAC算法）或使用RSA或ECDSA的公钥/私钥对进行签名。\nJWT的用途 JWT的主要目的是在各方之间传递声明。声明是对实体（通常是用户）的某些属性的断言，例如身份、访问权限等。这些声明以紧凑的形式编码为一个字符串，非常适合在Web环境中使用，尤其是在HTTP头部中作为承载令牌（Bearer Token）。\n在我们设计网站时，经常应用jwt用来鉴权，判断用户的登录状态，今天主要介绍利用GitHub - golang-jwt/jwt: Go implementation of JSON Web Tokens (JWT).包，实现Go语言下的jwt生成和解析。\n例如，在中间件中，我们可以通过设置过期日期，然后解析jwt，来判断用户的登录状态。\n安装 1 go get -u github.com/golang-jwt/jwt/v5 生成 本文介绍如何编码和解码一个自定义结构体\n为模拟真实使用环境，我们首先定义一个结构体类型，如下，包含用户名和id字段\n1 2 3 4 5 type UserJWTModel struct { ID int Username string jwt.RegisteredClaims } jwt.RegisteredClaims里包含了一些jwt约定好的字段，比如ExpiresAt，可以约定jwt的过期时间。以及其他字段，下面我们仅仅用到了ExpiresAt，更详细的请查阅jwt的文档。\n然后新建一个token，填入数据\n1 2 3 4 5 6 7 token := jwt.NewWithClaims(jwt.SigningMethodHS256, UserJWTModel{ 1, \u0026#34;dinglz\u0026#34;, jwt.RegisteredClaims{ ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Minute * 10)), }, }) 这里约定好过期时间是十分钟后\n然后用一个password生成jwt\n1 2 t, _ := token.SignedString([]byte(\u0026#34;password\u0026#34;)) fmt.Println(t) 完整示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/golang-jwt/jwt/v5\u0026#34; ) type UserJWTModel struct { ID int Username string jwt.RegisteredClaims } func main() { token := jwt.NewWithClaims(jwt.SigningMethodHS256, UserJWTModel{ 1, \u0026#34;dinglz\u0026#34;, jwt.RegisteredClaims{ ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Minute * 10)), }, }) t, _ := token.SignedString([]byte(\u0026#34;password\u0026#34;)) fmt.Println(t) } 解析 1 2 3 4 5 6 tokenAfter, e := jwt.ParseWithClaims(t, \u0026amp;UserJWTModel{}, func(t *jwt.Token) (interface{}, error) { return []byte(\u0026#34;password\u0026#34;), nil }) if e != nil { panic(e.Error()) } t是我们上面生成的字符串，然后选择解析的模型，最后在传回加密时的密码，即可得到解析后的token，如果过期或者密码错误等会使e!=nil，因此可以通过是否错误来判断登录是否过期。\n取回我们解析后的结构体\n1 cliamAfter := tokenAfter.Claims.(*UserJWTModel) 经验证，我们取出了传进去的数据。\n完整示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/golang-jwt/jwt/v5\u0026#34; ) type UserJWTModel struct { ID int Username string jwt.RegisteredClaims } func main() { token := jwt.NewWithClaims(jwt.SigningMethodHS256, UserJWTModel{ 1, \u0026#34;dinglz\u0026#34;, jwt.RegisteredClaims{ ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Minute * 10)), }, }) t, _ := token.SignedString([]byte(\u0026#34;password\u0026#34;)) fmt.Println(t) tokenAfter, e := jwt.ParseWithClaims(t, \u0026amp;UserJWTModel{}, func(t *jwt.Token) (interface{}, error) { return []byte(\u0026#34;password\u0026#34;), nil }) if e != nil { panic(e.Error()) } cliamAfter := tokenAfter.Claims.(*UserJWTModel) fmt.Println(cliamAfter) } 实际应用 比如我们可以在登录后往cookie中存入jwt，然后在需要鉴权的地方用中间件解析他，如果能成功则不用验证其他内容，因为在某种程度上我们可以认为jwt不会被伪造。\n","date":"2024-11-29T02:00:00Z","permalink":"https://dingdinglz.github.io/p/jwt%E7%9A%84%E5%BA%94%E7%94%A8/","title":"JWT的应用"},{"content":"回顾 本系列的第一篇文章写出来后，我发给了几位朋友帮我参考，想得出一些改进的意见，然后我发现，如果对于真正零基础的读者来说，他们要学习的显然还有如何下载安装使用自己的IDE，对此我在第一篇文章中只是浅浅地聊了一下。在本系列的后续文章中，我也没打算讲这部分内容，如果无法让自己的代码跑起来的话请自行百度吧，让我们把重点放在代码本身上。\nfirst try 下面我们将来完成我们的第一个c语言程序。一串命令，至少有一个开始执行的地方，就好像一条线路必须有一个起点。我们的程序将从哪里开始运行？从这里的讲解或许就可以看出本系列文章的思路与常规c语言教程的区别，在这里，我们将首先介绍函数的概念。\n1 2 3 4 5 int main() { return 0; } 这是一个最简单的c语言程序，正如我们所见到的，他什么也没有做。\n这里其实定义了一个函数，即main函数（main中文是主要的意思，main函数是整个程序的入口，我非常推荐这种以单词含义记忆的方式来进行编程学习）那么什么是函数呢？\n函数 让我们来举一个例子，比如你要开口说话，这在c语言中可能体现为在屏幕上显示一些内容，即输出，那么以我们目前的知识，如何输出呢？\n很明显，以我们目前的水平什么也做不了。但是c语言为我们提供了一系列工具以达到不同的目的，例如如果目前我们需要输出，我们并不需要知道输出的原理是什么，我们只需要发出指令输出即可，这一个个实现不同功能的工具在c语言里是函数，通过使用不同的函数，便可以实现不同的功能。\n为了拓展性考虑，函数分为自定义函数和库函数，前者由用户自己编写，或者使用别人写好的，而后者由c语言提供。\n我们在看回我们刚刚写好的程序，整个程序仅仅做了一件事，就是定义并实现main函数（后面聊函数那块的时候会详细阐述这一部分，现在记住格式即可）我们将代码写在main函数的函数体内（即两个大括号中间，return语句的上面）即可编写主体的功能。\nmain函数就是整个程序的入口，一个程序由main函数开始执行，现阶段初学者们可以理解为程序仅做了一件事，就是调用main函数。\nc语言的输出 刚刚介绍到库函数为我们提供了种种功能，那么专职输出的库函数便是printf，那么想要使用函数，我们必须包含函数所在的头文件，头文件是存放函数的地方，把函数理解成一个个工具的话，那么头文件就是存放工具的箱子，想要使用工具之前，我们就得把箱子给拿进来，这个拿箱子的命令就是include。include命令通常写在每个.c文件的最上方，如果你想使用某个函数的话，你必须包含他所在的头文件。\n比如printf并位于头文件stdio.h中\ninclude的具体使用方法如下\n1 #include\u0026lt;头文件名\u0026gt; 所以我们使用printf之前，必须\n1 #include\u0026lt;stdio.h\u0026gt; 刚刚所说的，我们应该把代码写在主函数的函数体里，那么我输出Hello,world的代码便如下：\n1 2 3 4 5 6 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello,world!\u0026#34;); return 0; } 这个版本可能就是你见到最多的所谓c语言的hello，world。\n从这个例子中也可以看出，函数的调用方法是函数名(参数1，参数2\u0026hellip;)。\n同时，每行代码的后面都需要加上;。\n\u0026ldquo;Hello,world\u0026quot;作为我们的参数1，用双引号扩了起来，表示一个字符串类型的量，这将在我们后面讨论变量的时候说到。\n总结 看完这一篇，你就学会了输出，也搭建起了程序的基本框架的逻辑。让我们printf一下有意思的东西吧，比如printf(\u0026ldquo;c is the best language\u0026rdquo;); \u0026#x1f602; 让我们尝试输出一些别的有意思的东西吧。\n","date":"2024-11-22T02:00:00Z","permalink":"https://dingdinglz.github.io/p/learning-c%E8%AF%AD%E8%A8%802/","title":"Learning C语言(2)"},{"content":"为什么要写这个系列 身边很多朋友刚开始学c，以前从来没有接触过编程语言，甚至没有接触过计算机，对于c语言存在一种惧怕的心理，把它当成了某种特别高端的东西。\n很多人看似会写c语言，实际上不能理解背后的原理，只能盲目的套代码模板，导致后续的学习卡住，且没有自己的创新能力。\n这个系列想做到什么？ 以我的思路从零开始层层深入c语言\n讲清楚c语言基础代码的概念和编写方法\nwarning 本系列以我的思路推进，可能与常见的c语言教程的学习路径大相径庭\n建议阅读本文前先掌握一部分c语言知识，以我目前的想法仅仅是解决一些新手只会写不懂道理，不能举一反三的问题。\n那么让我们开始吧\nc语言简述 用途 任何编程语言都起到了让计算机执行我们想让他执行的命令的作用，也就是说写一个应用，在windows上可能是.exe文件。\n编程语言绕开了底层的复杂，让我们以一种人类可以理解的方式编写我们想要的程序。c作为一种高级语言，从某种程度上来说，是具有极高的可读性的。\n想让程序实现我们想要的功能，就需要写出对应的代码。因此，实现一个程序仅仅需要我们把一步一步的代码写在一起，写代码也不是电视里所吹嘘的那样无比高端的东西，他只需要我们写，写一种计算机能够理解的语言，去命令计算机做我们想让他做的事。这也就是为什么编程语言被叫做语言了吧，当然计算机不会违逆我们的命令（在某种程度上），而听你说话的人可不一定。\n编译 先去除掉这种编程好厉害啊的思想，那我们开始正式进入这门语言。\n首先我们要清楚的事，计算机并不能直接读懂编程语言，这很遗憾，我们需要借助某种工具把编程语言给转换成计算机可以直接执行的东西。\n我们把源码（也就是c语言的代码）都放在c语言的源文件里，也就是.c文件。.c文件本质上就是一个文本文件，里面写着我的代码。我们现在需要一种工具把这个.c文件转换成可执行的文件，也就是windows下的exe文件，就需要用到编译器。\n编译器的作用目前可以理解为源码-\u0026gt;可执行程序。c语言比较知名的编译器有gcc等。\n这个时候大家可能就要问了，我平常在ide里写代码，直接就能生成可执行文件，为什么没有用到编译器呢。其实生成的过程是由ide进行了编译器的调用。你们使用的一些ide例如VS和Dev-cpp就是自带编译器的，他们调用了自带的编译器进行生成，因此你可能并没有接触到编译器的使用。如果你用的是VSCODE的话，那么你在配置c语言环境的时候应该经历过了编译器的配置，那么你应该可以理解编译器的作用了\n也是比较推荐大家使用下vsc，自行配置一下环境可以加深对上述概念的理解，不过新手使用dev或许也是有好处的，因为没有实时提示或许可以提升你对基础知识的理解和记忆吧。\n还有一点需要注意的是，不少人认为一个应用只能有一个源文件，其实不是的，一个应用可以写成很多个c文件，比如把不同的功能写在不同的文件里，最后用头文件连接，这将在我们后续聊到函数的时候再提这一点。\n使用gcc编译 例如，把1.c文件编译成1.exe\n1 gcc 1.c -o 1.exe 编译多个文件生成一个应用\n例如：\n1 gcc 1.c 2.c 3.c -o 1.exe -o是object的意思，可以理解为生成1.exe\n总结 本文作为该系列的开坑之作，仅仅唠完了前置的一些东西和我想说的一些话，下一篇文章将开始进入具体的代码。\n","date":"2024-11-21T02:00:00Z","permalink":"https://dingdinglz.github.io/p/learning-c%E8%AF%AD%E8%A8%801/","title":"Learning C语言(1)"},{"content":"二叉树介绍 二叉树_百度百科\n二叉树由一个个节点构成，最上方是根节点，一个节点可能有它的左节点和右节点，由左节点作为根节点的树叫做左子树，由右节点作为根节点的树叫做右子树。\n如图为一颗有七个节点的二叉树，节点1便是这颗树的根节点，而红圈1为根节点的左子树，红圈2为根节点的右子树。\n如何描述一颗树 除了像这样直接画一张图出来，如何描述一颗树呢？\n描述节点的对应关系：比如，直接叙述节点1为根节点，2和3分别为1的左子树和右子树。再描述2的左子树和右子树有等等。\n这样直接叙述固然可行，下面给大家介绍几种常见的遍历树的方式。\n层序遍历 即按照每层描述这颗树的元素。自上而下，自左而右。\n按照上图，该树的层序遍历为：\n1 1 2 3 4 5 6 7 前序遍历 从根节点开始，按照由节点本身，左节点，右节点的形式输出值。如果该节点有左子树和右子树，也按照该顺序。\n按照上图，该树的前序遍历为：\n1 1 2 4 5 3 6 7 中序遍历 从根节点开始，按照由左节点，节点本身，右节点的形式输出值。如果该节点有左子树和右子树，也按照该顺序。\n按照上图，该树的中序遍历为：\n1 4 2 5 1 6 3 7 后序遍历 从根节点开始，按照由左节点，右节点，节点本身的形式输出值。如果该节点有左子树和右子树，也按照该顺序。\n按照上图，该树的后序遍历为：\n1 4 5 2 6 7 3 1 注意 这四种遍历方法中，仍给两种遍历方法，可以帮我们得到一颗确定的树。\n建树 在我们的代码中如何表示出一棵树？\n我们先来想想每个节点的特性，首先，每个节点自身都有一个值，然后它可能有左节点或者右节点。（如果这个节点既没有左节点，也没有右节点的话，那么这个节点被称为叶子节点。）那么我们可以用一个结构体来表示每个节点。\n1 2 3 4 5 6 struct Node { Node * left,* right; // 左节点的指针和右节点的指针 int value; // 本身的值 Node():left(NULL),right(NULL){}; // 初始化左节点和右节点为空 }; 由于我们不清楚树的大小，因此我们对于每个节点都采用动态添加的方法。这个时候就要用到 new 和 delete 关键字。new可以动态申请一个内存用于对应的节点，delete可以删除(或者说归还更合适一点)掉申请的内存。\n因此，我们可以这样直接新建一个节点。\n1 2 3 4 Node * newnode() { return new Node(); } 那我们就可以这样构建一棵树。\n1 2 3 4 5 6 Node * root = newnode(); // 构建根节点 root-\u0026gt;value = 1; root-\u0026gt;left = newnode(); // 构建根节点的左节点 root-\u0026gt;left-\u0026gt;value = 2; root-\u0026gt;right = newnode(); // 右节点 root-\u0026gt;right-\u0026gt;value = 3; 建出的树如图。\ndfs 那么我们如何遍历这颗树？以前序遍历为例。\n1 2 3 4 5 6 7 void dfs(Node * root) { cout \u0026lt;\u0026lt; root-\u0026gt;value \u0026lt;\u0026lt; \u0026#34; \u0026#34;; if(root-\u0026gt;left!=NULL) dfs(root-\u0026gt;left); if(root-\u0026gt;right!=NULL) dfs(root-\u0026gt;right); return; } 这种遍历方式被称作深度优先搜索。通常使用递归的方式实现，既然是中左右的顺序，那么拿到一个节点，就立马输出这个节点的值，然后再递归的去搜它的左节点和右节点，直到搜完为止。\n我开始遍历的方式便是：\n1 dfs(root); 同样的，我们的delete操作也可以用dfs的形式来写。\n删完它的左右节点，再删他本身。\n1 2 3 4 5 6 7 void remove_tree(Node * u) { if(u==NULL) return; remove_tree(u-\u0026gt;left); remove_tree(u-\u0026gt;right); delete u; } bfs 曾经的博客中我介绍了stl的相关内容，那么借助queue队列，我们可以实现层序遍历。自上而下，自左而右。\n1 2 3 4 5 6 7 8 9 10 11 12 13 void bfs(Node * root) { queue\u0026lt;Node *\u0026gt; q; q.push(root); while(!q.empty()) { Node * cnt = q.front(); q.pop(); cout \u0026lt;\u0026lt; cnt-\u0026gt;value \u0026lt;\u0026lt; \u0026#34; \u0026#34;; if(cnt-\u0026gt;left!=NULL) queueTree.push(cnt-\u0026gt;left); if(cnt-\u0026gt;right!=NULL) queueTree.push(cnt-\u0026gt;right); } } 首先把第一层的元素扔进队列，也就是根节点，然后依次添加左节点，右节点，左节点再添加左节点右节点。\n根据队列的特性，就可以实现自上而下，自左而右地访问到每一个节点。\n这种遍历的方法被称做广度优先搜索。\n例题 uva122 题目链接：Trees on the level - UVA 122 - Virtual Judge\n题意 题意不难理解，即为先建树，再按层序遍历输出元素。\n难点解析 每个输入的格式显得有些难以处理 如何判断是否存在重复节点？ 如何判断必要节点不存在？ 让我们挨个解析\n难点1：输入处理 让我们以(7,LLL)为例。\n我们从这个字符串中至少应该获取到两个数据，即节点的值和表示位置的字符串，那么我们可以用到string类自带的find函数和substr函数。\nfind函数可以查找到需要查找的字符在字符串中的位置(从0开始)\nsubstr函数的第一个参数为子字符串开始的位置，第二个参数为需要截取的长度，因此，我们可以搜索,的位置，然后分别截取即可，示例代码如下\n1 2 3 // nodeTen为类似(7,LLL)的结构 nodeTen.substr(nodeTen.find(\u0026#39;,\u0026#39;)+1,nodeTen.length() - nodeTen.find(\u0026#39;,\u0026#39;) - 2) // LLL atoi(nodeTen.substr(1,nodeTen.find(\u0026#39;,\u0026#39;)-1).c_str()) // 7 难点2：判断节点是否重复 在node结构体中添加一个bool类型的变量用于记录之前是否赋值过即可。\n难点3：判断必要节点不存在 深搜或广搜一遍树，如果存在节点未被赋值，则说明必要节点不存在。\n示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; struct Node { bool haveValue; Node * left,* right; int value; Node():haveValue(false),left(NULL),right(NULL){}; }; Node * root = NULL; Node * newnode() { return new Node(); } void remove_tree(Node * u) { if(u==NULL) return; remove_tree(u-\u0026gt;left); remove_tree(u-\u0026gt;right); delete u; } bool addNode(string ten,int value) { Node * currentNode = root; for(int i=0;i\u0026lt;ten.length();i++) { if(ten[i] == \u0026#39;L\u0026#39;) { if(currentNode-\u0026gt;left==NULL) currentNode-\u0026gt;left = newnode(); currentNode = currentNode-\u0026gt;left; } else { if(currentNode-\u0026gt;right==NULL) currentNode-\u0026gt;right = newnode(); currentNode = currentNode-\u0026gt;right; } } if(currentNode-\u0026gt;haveValue) { return false; } currentNode-\u0026gt;haveValue = true; currentNode-\u0026gt;value = value; return true; } int main() { string nodeTen; while(cin \u0026gt;\u0026gt; nodeTen) { remove_tree(root); root = newnode(); bool flag = true; flag = addNode(nodeTen.substr(nodeTen.find(\u0026#39;,\u0026#39;)+1,nodeTen.length() - nodeTen.find(\u0026#39;,\u0026#39;) - 2),atoi(nodeTen.substr(1,nodeTen.find(\u0026#39;,\u0026#39;)-1).c_str())); while(cin \u0026gt;\u0026gt; nodeTen \u0026amp;\u0026amp; nodeTen!=\u0026#34;()\u0026#34;) { if(flag) { flag = addNode(nodeTen.substr(nodeTen.find(\u0026#39;,\u0026#39;)+1,nodeTen.length() - nodeTen.find(\u0026#39;,\u0026#39;) - 2),atoi(nodeTen.substr(1,nodeTen.find(\u0026#39;,\u0026#39;)-1).c_str())); } } if(nodeTen == \u0026#34;()\u0026#34;) { if(!flag) { cout \u0026lt;\u0026lt; \u0026#34;not complete\\n\u0026#34;; continue; } else { bool rightAns = true; vector\u0026lt;int\u0026gt; ans; queue\u0026lt;Node *\u0026gt; queueTree; queueTree.push(root); while(!queueTree.empty()) { Node * cnt = queueTree.front(); queueTree.pop(); if(!cnt-\u0026gt;haveValue) { rightAns = false; break; } ans.push_back(cnt-\u0026gt;value); if(cnt-\u0026gt;left!=NULL) queueTree.push(cnt-\u0026gt;left); if(cnt-\u0026gt;right!=NULL) queueTree.push(cnt-\u0026gt;right); } if(!rightAns) { cout \u0026lt;\u0026lt; \u0026#34;not complete\u0026#34;; } else { for(auto i = ans.begin();i!=ans.end();i++) { cout \u0026lt;\u0026lt; *i; if(i!=ans.end()-1) { cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } } cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } } return 0; } uva548 题目链接\n这题很显然符合我们刚刚提到的结论，给出四种遍历方式中的两种，一定可以确定一棵树，自然也就可以输出其第三种遍历。\n那么本题中根据中序和后序，我们应该如何建树呢？\n以这组数据为例\n1 2 3 2 1 4 5 7 6 3 1 2 5 6 7 4 后序遍历的形式是左右中，也就是说，最后一个子节点一定是这棵树的根节点。\n而中序遍历的形式是左中右，也就是说，根节点的左边是左子树的中序遍历，根节点的右边为右子树的中序遍历。\n可以得出，左子树的元素个数为3，因为后序遍历以左右中的形式，所以左子树的后序遍历为前三个元素。右子树可以类比。\n根据分治的思想，我们就可以如此不断的建树。直到中序遍历和后序遍历都只有一个元素为止。\n建树完成，再深搜一遍确定最小值即可。\n因此，示例代码如下，代码中用到的方式是以数组的形式建树（用两个数组分别表示对应节点的左节点和右节点是啥）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #include \u0026lt;iostream\u0026gt; #include \u0026lt;sstream\u0026gt; using namespace std; int tree_zhong[10001]; int tree_hou[10001]; int lch[10001],rch[10001]; int n; void loadTree(string cmd,string pos) { stringstream s(cmd); n=0; int x; if(pos == \u0026#34;zhong\u0026#34;) { while(s\u0026gt;\u0026gt;x) { tree_zhong[n] = x; n++; } } else { while(s\u0026gt;\u0026gt;x) { tree_hou[n] = x; n++; } } } int buildTree(int l1,int r1,int l2,int r2) { if (l1\u0026gt;r1) { return -1; } int root = tree_hou[r2]; int p; for(int i=l1;i\u0026lt;=r1;i++) { if(tree_zhong[i] == root) { p = i; break; } } lch[p] = buildTree(l1,p-1,l2,l2+p-l1-1); rch[p] = buildTree(p+1,r1,l2+p-l1,r2-1); return p; } int sumMin = -1; int minID = -1; void dfs(int root,int sum) { sum += tree_zhong[root]; if(lch[root]==-1 \u0026amp;\u0026amp; rch[root]==-1) { if(sumMin == -1) { sumMin = sum; minID = root; } if(sum == sumMin) { if(tree_zhong[root] \u0026lt; tree_zhong[minID]) //不加这个判断uva也过了 { sumMin = sum; minID = root; } } if(sum \u0026lt; sumMin) { sumMin = sum; minID = root; } return; } if(lch[root]!=-1) { dfs(lch[root],sum); } if(rch[root]!=-1) { dfs(rch[root],sum); } } int main() { string cmd; while(getline(cin,cmd)) { sumMin = -1; minID = -1; loadTree(cmd,\u0026#34;zhong\u0026#34;); getline(cin,cmd); loadTree(cmd,\u0026#34;hou\u0026#34;); int root = buildTree(0,n-1,0,n-1); dfs(root,0); cout \u0026lt;\u0026lt; tree_zhong[minID] \u0026lt;\u0026lt; endl; } return 0; } uva839 题目链接\n这题虽然一眼看上去是二叉树的形式，实际上并不需要建树。\n通过对于引用的妙用可以实现同步左子树和右子树的重量的作用。具体代码如下，易懂但思路难想，因为其特殊结构被引入到该文中。\n示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include\u0026lt;iostream\u0026gt; using namespace std; bool solve(int \u0026amp; w) { int w1,l1,w2,l2; cin \u0026gt;\u0026gt; w1 \u0026gt;\u0026gt; l1 \u0026gt;\u0026gt; w2 \u0026gt;\u0026gt; l2; bool b1 = true,b2 = true; if(w1==0) b1 = solve(w1); if(w2==0) b2 = solve(w2); w = w1 + w2; return b1 \u0026amp;\u0026amp; b2 \u0026amp;\u0026amp; (w1*l1 == w2*l2); } int main() { int n; cin \u0026gt;\u0026gt; n; for(int i=1;i\u0026lt;=n;i++) { int w; if(solve(w)) { cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; } if(i!=n) { cout \u0026lt;\u0026lt; endl; } } return 0; } ","date":"2024-10-24T02:00:00Z","permalink":"https://dingdinglz.github.io/p/%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"二叉树"},{"content":"前言 除了一些新颖的语法，cpp中仍然有一部分多于c的地方，便是stl，基于template技术为我们实现了一些可直接使用的数据结构。例如栈，队列，map等，本文就为大家介绍部分stl。\n栈(stack) 栈的概念 摘自百度百科\n在百科中，给出了栈的基本概念及实现方法。但在cpp中，有实现好的栈，位于头文件stack中。\n1 #include \u0026lt;stack\u0026gt; 通过stack的形式即可声明一个栈。T为数据类型。\n例如：\n1 stack\u0026lt;int\u0026gt; s; 通过push方法和pop方法分别可以实现进栈和出栈的操作。\n通过top方法则可以获取栈顶元素。\n请看示例代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; using namespace std; int main() { stack\u0026lt;int\u0026gt; test; int t = 5; test.push(5); test.push(6); test.push(t); t = 10; test.push(9); test.pop(); cout \u0026lt;\u0026lt; test.top(); return 0; } vector Vector在我眼里可以视作一个动态数组，对于无法确定数组具体上限的情况下，vector无疑是个较好的选择。vector位于头文件vector中，下面为大家介绍它的相关使用方法。\n1 #include \u0026lt;vector\u0026gt; 定义 定义方法与栈类似。vector声明一个vector，例如\n1 vector\u0026lt;int\u0026gt; v; push_back方法 通过push_back方法可以往vector中塞入元素，既然我们把它当做动态数组来理解，那么就是往动态数组中加入元素。例如：\n1 2 v.push_back(1); v.push_back(2); 就是往v中加入了两个元素，分别是1，与2。\npop_back方法 通过pop_back方法可以删除最后加入的元素，也就是说\n1 v.pop_back(); 此时v中的2被弹出，只剩下1一个元素。\n遍历vector 此时需要引入iterator的概念，可以理解为指向vector中的元素的指针。\n通过begin方法和end方法，可以获取指向第一个元素和最后一个元素，通过指针自增的方法可以实现从第一个元素一直遍历到最后一个元素的效果。\n例如，如果需要遍历v，可以操作如下。\n1 2 3 4 for(auto i = v.begin();i!=v.end();i++) { cout \u0026lt;\u0026lt; (*i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // i可以理解为此时遍历到的元素的指针，*i即可取出元素。 } auto关键字可以自动根据赋值的类型推导出新定义变量的类型。属于c++11新增的特性。\n此时对于i来说，推导出的类型为vector::iterator。\n对于倒序遍历，vector提供了两个很有意思的函数rbegin和rend。通过把上面示例代码中的begin替换成rbegin，把end替换成rend，即可实现倒序遍历的效果。\nresize方法 resize方法可以调整vector的容量，从而实现拓展或者缩减vector的效果。\n如果resize后新的容量小于原vector中的元素的容量，则会删除多出来的相对加入位置靠后的元素。\n例如\n1 v.resize(0); 将容器大小调整为零，还有一个可以理解的意义，即清空vector。\n示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { vector\u0026lt;int\u0026gt; test; test.push_back(5); test.pop_back(); test.push_back(4); test.push_back(5); test.push_back(2); test.push_back(3); test.resize(3); for(auto i = test.begin();i!=test.end();i++) { cout \u0026lt;\u0026lt; (*i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 集合(set) set位于头文件set中\n1 #include \u0026lt;set\u0026gt; set虽然感觉在我日常开发或者写题中使用不多，可能是我之前并不怎么了解这个的原因，但它确实是一个很有趣的东西，在我看来，它在形式上类似于vector，但是要多出两个特性。\n不允许重复元素的存在，即你可以插入很多次同一个元素(合法)，但set中只会保留一个。\n自动排序，按照自小到大的顺序。因此，使用自定义类型时，应该注意实现\u0026lt;符号。\n定义 set，T为数据类型\n1 set\u0026lt;int\u0026gt; s; 插入元素 insert方法，例如\n1 2 3 s.insert(1); s.insert(2); s.insert(3); 删除元素 erase方法可以删除元素，例如\n1 s.erase(1); 遍历 与vector相同，不在赘述，但值得注意的是，vector是按照插入顺序排列元素，而set则是按照升序排列元素。\n示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; test; test.insert(5); test.insert(4); test.insert(5); test.insert(6); test.insert(5); test.insert(1); for(auto i = test.begin();i!=test.end();i++) { cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; for(auto i = test.rbegin();i!=test.rend();i++) { cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 队列 队列的概念：队列（常用数据结构之一）_百度百科\ncpp中实现了队列，位于头文件queue中。\n1 #include \u0026lt;queue\u0026gt; 定义方法queue，T为类型名。\n插入与弹出 即为push方法与pop方法，与前面介绍的几种结构类似，不在赘述，请大家自行理解，也可以参照示例代码。\n获取队顶元素和队尾元素 分别是front方法和back方法，详见示例。\n优先队列 优先队列与队列类似，只是多出了个升序排列的特性，类型名为priority_queue。\n使用方法与queue完全相同，只是多出了一个类似于自动排序的功能。\n示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; int main() { queue\u0026lt;int\u0026gt; test; test.push(123); test.push(123121); test.push(222); test.pop(); cout \u0026lt;\u0026lt; test.back() \u0026lt;\u0026lt; test.front(); cout \u0026lt;\u0026lt; endl; priority_queue\u0026lt;int\u0026gt; test2; test2.push(5); test2.push(9); test2.push(2); test2.push(4); test2.push(1); test2.push(3); test2.pop(); cout \u0026lt;\u0026lt; test2.top(); return 0; } map map本质上就是一个键值对，位于头文件map中\n1 #include \u0026lt;map\u0026gt; 它的定义形式为map\u0026lt;T1,T2\u0026gt;，T1为键的类型，T2为值的类型。\n一个确定的键对应一个确定的值。\n例如：\n1 2 3 4 map\u0026lt;string,int\u0026gt; test; test[\u0026#34;a\u0026#34;] = 1; test[\u0026#34;b\u0026#34;] = 2; test[\u0026#34;a\u0026#34;] = 3; 该段代码中先是定义了一个map变量。\n然后去添加键值对。由于键与值是一一对应的，现在map中实际上只存在两个键值对，即a-\u0026gt;3，b-\u0026gt;2。\n该例子很好的体现了键值对的操作方法。即变量名[键] = 值的方法进行操作。\n用于判断map中是否存在特定的键，提供了count方法，可以或许对应键的数量。（其实也只有1和0，因为一个键只对应一个值。所以为什么不设计成exist的形式呢）\n下面是示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; int main() { map\u0026lt;string,int\u0026gt; test; test[\u0026#34;a\u0026#34;] = 1; test[\u0026#34;b\u0026#34;] = 2; test[\u0026#34;a\u0026#34;] = 3; cout \u0026lt;\u0026lt; test.count(\u0026#34;a\u0026#34;) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; test[\u0026#34;a\u0026#34;] \u0026lt;\u0026lt; endl; return 0; } 相关练习 uva442 题目链接：Matrix Chain Multiplication - UVA 442 - Virtual Judge\n涉及到栈和map的使用，给出示例代码，请大家自行理解。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;stack\u0026gt; using namespace std; struct Matrix { Matrix(int a=0,int b=0):a(a),b(b){} int a; int b; }; int main() { map\u0026lt;char,Matrix\u0026gt; MatrixMap; int n; cin \u0026gt;\u0026gt; n; for(int i=1;i\u0026lt;=n;i++) { char cnt1; int cnt2,cnt3; cin \u0026gt;\u0026gt; cnt1 \u0026gt;\u0026gt; cnt2 \u0026gt;\u0026gt; cnt3; MatrixMap[cnt1] = Matrix(cnt2,cnt3); } string inputCom; while(cin \u0026gt;\u0026gt; inputCom) { stack\u0026lt;Matrix\u0026gt; cheng; int ans = 0; bool success = true; for(int i=0;i\u0026lt;inputCom.length();i++) { if(inputCom[i]!=\u0026#39;(\u0026#39; \u0026amp;\u0026amp; inputCom[i]!=\u0026#39;)\u0026#39;) { cheng.push(MatrixMap[inputCom[i]]); } if(inputCom[i] == \u0026#39;)\u0026#39;) { Matrix m1 = cheng.top(); cheng.pop(); Matrix m2 = cheng.top(); cheng.pop(); if(m1.a != m2.b) { success = false; break; } ans += m2.a * m2.b * m1.b; cheng.push(Matrix(m2.a,m1.b)); } } if(!success) { cout \u0026lt;\u0026lt; \u0026#34;error\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } } return 0; } uva514 题目链接：Rails - UVA 514 - Virtual Judge\n涉及到队列和栈的使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include\u0026lt;iostream\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;queue\u0026gt; using namespace std; int main() { int n; while(cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n!=0) { int cnt; while(cin \u0026gt;\u0026gt; cnt \u0026amp;\u0026amp; cnt != 0) { queue\u0026lt;int\u0026gt; rail; stack\u0026lt;int\u0026gt; realRail; rail.push(cnt); for(int i=2;i\u0026lt;=n;i++) { int _cnt; cin \u0026gt;\u0026gt; _cnt; rail.push(_cnt); } for(int i=1;i\u0026lt;=n;i++) { realRail.push(i); while(!realRail.empty() \u0026amp;\u0026amp; !rail.empty() \u0026amp;\u0026amp; realRail.top() == rail.front()) { rail.pop(); realRail.pop(); } } if(!rail.empty()) { cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; } } cout \u0026lt;\u0026lt; endl; } return 0; } 总结 上述题目离开stl当然能做，但使用给出的stl显得可读性更高并且更加方便，使开发效率大大增强。在认识到stl便利性的同时应该了解stl的效率相对不高，在部分oi题中可能会导致超时等问题，需要斟酌使用。\n","date":"2024-10-23T02:00:00Z","permalink":"https://dingdinglz.github.io/p/%E6%B5%85%E8%B0%88stl/","title":"浅谈STL"},{"content":"简述 自从酷Q时代开始乃至更早时期，QQ机器人便出现在大家的视野里，由于被使用于一些不正当领域以及某些不可告人的原因，QQ Robot被QQ官方ban了很长时间，直到最近官方放出了部分机器人权限，以及onebot等对于协议的贡献，QQ Robot恢复了部分功能，dingbot便由于本作者的需求重构出了v2版本。\n链接：https://github.com/dingdinglz/dingbot\n已支持功能 请移步github查看\n实现方法 golang + html\ngolang下对接Lagrange，以fiber框架作为web框架，html以layui构建前端界面\n画廊 编译方法 前置条件 安装golang\n编译方法 1 go build 产物 将所得的dingbot.exe（其他系统后缀可能不同）与web文件夹复制到新的文件夹中，此时的dingbot可以直接运行。\n此时你的文件夹结构应该为\n1 2 - dingbot[.exe] - web 运行方法 打开dingbot可执行文件，第一次使用会为你打开初始化界面，完成设置后重启dingbot即可。\n首先在账号设置栏中保存QQ账号与密码，点击保存。\n点击下方登录进行登录，初次登录需要扫描二维码。后续登录如sig未失效可直接登录。\n提示登录成功后机器人便进入正常运行状态。\n关键词回复 点击创建可以创建新的关键词。\n精确识别为消息必须完美符合关键词才会发送回复内容。\n非精确识别则如果消息包含关键词即发送回复内容。\n群接收开关 \u0026amp;\u0026amp; 好友接收开关 开启后机器人才会对对应群和好友的消息进行处理。否则dingbot自带功能与插件功能无法在对应的对话中生效。\n插件 新建插件后即会为你创建一个新的插件源码，点击编辑后会进入插件编辑器中进行编辑。\n一个完整的插件至少拥有插件信息提供事件，即事件中第一个，将其拖至编辑器中，用文本填充相关信息即可。\n事件 所有的事件的实现方法都拖至事件内部处理。\n在对应的事件中可以使用对应的参数。\n保存 编辑完插件后记得保存，否则下次将丢失上次编辑。\n生成 插件编辑完后无法立即进入工作状态，点击生成插件后才会生成正式的插件文件，若你可以在插件列表中看到该插件，即为生成成功，并进入工作状态。\n插件的获取 当然，除了自己编写插件以外，可以从社区下载他人制作完成的插件，复制到对应的文件夹中，若你可以在插件列表中看到该插件，即为添加成功。\n","date":"2024-10-16T02:00:00Z","permalink":"https://dingdinglz.github.io/p/dingbot-v2/","title":"dingbot v2"}]